{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":"<p>En esta web se van a tratar los siguientes contenidos:</p> <ul> <li> <p>Arduinoblocks</p> <ul> <li>Introducci\u00f3n</li> <li>Usuarios gestionados</li> <li>Creaci\u00f3n de proyectos para alumnos</li> </ul> </li> <li> <p>IDE 2 de Arduino</p> <ul> <li>Introducci\u00f3n</li> <li>C\u00f3digo en Arduinoblocks</li> <li>Descarga del IDE</li> <li>Ventana principal del IDE</li> <li>Caracter\u00edsticas principales del IDE 2.0</li> </ul> </li> <li> <p>ESP32 STEAMakers</p> <ul> <li>Introducci\u00f3n</li> <li>Consumo de energia</li> <li>Sensores t\u00e1ctiles capacitivos</li> <li>Sensores internos</li> <li>Tarjeta microSD</li> </ul> </li> <li> <p>Placa Imagina 3DBot</p> <ul> <li>Introducci\u00f3n</li> <li>Asociaci\u00f3n de pines y componentes</li> <li>Teor\u00eda b\u00e1sica de IoT</li> <li>Actividades con la placa Imagina<ul> <li>B\u00e1sicas</li> <li>De ampliaci\u00f3n</li> <li>Avanzadas</li> </ul> </li> </ul> </li> <li> <p>3DBot</p> <ul> <li>Montaje versi\u00f3n impresa</li> <li>Montaje versi\u00f3n corte en madera</li> <li>Actividades con el 3Dbot<ul> <li>B\u00e1sicas</li> <li>De ampliaci\u00f3n</li> <li>Avanzadas</li> </ul> </li> <li>Archivos del dise\u00f1o</li> </ul> </li> </ul> <p>Todos los contenidos est\u00e1n basados en los del aula virtual Robolot Formaci\u00f3 creados por Toni Hortal para Robolot con aportaci\u00f3n de algunas actualizaciones y algunas ampliaciones tematicas.</p>"},{"location":"3DBot/AAm_3DBot/","title":"Actividades 3DBot","text":"<p> <p> Robot 3DBot </p> <p></p>"},{"location":"3DBot/AAm_3DBot/#a_05-robot-seguidor-de-linea","title":"A_05. Robot seguidor de l\u00ednea","text":"<p>Podemos hacer que el robot Imagina 3DBot se comporte como seguidor de l\u00ednea utilizando los sensores de l\u00ednea fotoel\u00e9ctricos. Para ello, nos ayudaremos de las se\u00f1ales del sensor de l\u00ednea izquierdo (SE), conectado a SL (Sensor Left) y el sensor de l\u00ednea derecho (SD), conectado a SR (Sensor Right). Estos dos sensores \u00f3pticos permiten distinguir entre superficies de colores claros y superficies de colores oscuros.</p> <p>El sensor de l\u00ednea que usamos es un m\u00f3dulo TCRT5000, un sensor de m\u00f3dulo \u00f3ptico (reflexivo) con comparador LM393, que detecta obst\u00e1culos con alta precisi\u00f3n. El sensor tiene una construcci\u00f3n compacta d\u00f3nde el emisor de luz y el receptor se colocan en la misma direcci\u00f3n para detectar la presencia de un objeto utilizando la reflexi\u00f3n del infrarrojo sobre el objeto. La longitud de onda de trabajo es 950nm.</p> <p>El transmisor es LED de infrarrojos y el receptor fototransistor. Mediante el uso del comparador LM393 el m\u00f3dulo tiene una salida binaria (D0) que esta en nivel 1 (objeto es detectado). El sensor permite la detecci\u00f3n de un objeto a una distancia de hasta 12 mm. El m\u00f3dulo tiene un potenci\u00f3metro para el ajuste de la sensibilidad y los LED que indican el estado de alimentaci\u00f3n y el sensor. El m\u00f3dulo dispone de salidas: anal\u00f3gicos y digitales.</p> <p> <p> Sensor IR TCRT5000 </p> <p></p> <p>Para entender el programa, vamos a representar los dos sensores \u00f3pticos con la siguiente figura:</p> <p> <p> Representaci\u00f3n de los sensores IR TCRT5000 </p> <p></p> <p>Al ponerlos sobre una l\u00ednea negra, se pueden dar los siguientes casos:</p> <p> <p> Sensores sobre l\u00ednea negra </p> <p></p> <p>En el caso A de la imagen superior, el robot se ha salido hacia la izquierda, por lo que habr\u00e1 que girar a la derecha hasta que ambos sensores vuelva a encontrarse en la l\u00ednea negra.</p> <p>En el caso B el robot debe avanzar en l\u00ednea recta porque va bien, y en el caso C deber\u00e1 girar hacia la izquierda para corregir su rumbo, ya que se ha salido por la derecha. Con las curvas el funcionamiento es el mismo.</p> <p>Adem\u00e1s, cabe a\u00f1adir el caso en el que el robot se sale totalmente de la l\u00ednea negra (D), momento en el que ambos sensores est\u00e1n en superficie blanca.</p>"},{"location":"3DBot/AAm_3DBot/#a_05_1-primera-version-de-seguidor-de-linea","title":"A_05_1. Primera versi\u00f3n de seguidor de l\u00ednea","text":"<p>Para empezar, vamos a realizar un programa que act\u00fae ante los casos A, B y C. Para el caso D, en el que el robot pierde totalmente la referencia de la l\u00ednea, vamos a hacer simplemente que se detenga.</p> <p>Lo primero que hacemos al iniciar el programa es guardar el estado de cada sensor de l\u00ednea en una variable booleana, que son aquellas que s\u00f3lo pueden tomar como valores 0 y 1. Esto significa que, o se detecta l\u00ednea negra, o se detecta l\u00ednea blanca. \u00a1Aqu\u00ed no hay medias tintas!</p> <p>Las variables booleanas las encontramos, al igual que las dem\u00e1s, en el apartado \"Variables\" de Arduinoblocks.</p> <p>Tambi\u00e9n vamos a utilizar el bloque correspondiente a los sensores \u00f3pticos \"L\u00ednea negra detectada\". Este bloque nos permite diferenciar entre una superficie negra y una blanca, y podemos encontrarlo en el apartado \u201c3dBot\u201d:</p> <p> <p> Bloque l\u00ednea negra detectada </p> <p></p> <p>Es importante tener en cuenta que este bloque indica se\u00f1al de activaci\u00f3n cuando se encuentra sobre l\u00ednea negra.</p> <p>As\u00ed, al guardar las lecturas del sensor de l\u00ednea en una variable booleana, cuando el sensor est\u00e9 sobre l\u00ednea negra, esta variable valdr\u00e1 1. Sobre l\u00ednea blanca valdr\u00e1 0.</p> <p>La combinaci\u00f3n de estas variables con los condicionales \u201csi\u2026 hacer\u2026\u201d funciona de forma directa, sin tener que utilizar bloque de comparaci\u00f3n. En la siguiente imagen vemos una condici\u00f3n que expresa directamente que, si la variable \u201cSensor derecho\u201d vale 1, entonces que se ejecute la acci\u00f3n\u2026</p> <p> <p> Bloque si...hacer para variable booleana </p> <p></p> <p>Para completar el proceso, cabe se\u00f1alar tambi\u00e9n el uso del bloque \u201cno\u201d, situado en el apartado \u201cL\u00f3gica\u201d de Arduinoblocks, que lo que hace es negar lo que se coloque detr\u00e1s de \u00e9l.</p> <p>Por tanto, el siguiente condicional indica que, si el valor de \u201cSensor derecho\u201d NO es 1, es decir, es 0, entonces que se ejecute la acci\u00f3n. Esta condici\u00f3n, que es el caso contrario a la anterior, se cumplir\u00e1 cuando el sensor est\u00e9 sobre superficie blanca.</p> <p> <p> Bloque si...hacer para variable booleana negada </p> <p></p> <p>El programa para la actividad es el siguiente:</p> <p> <p> A_05_1_3DBot Acceder al programa</p> <p></p> <p>Es importante destacar que, dependiendo de la velocidad del robot y de lo cerradas que sean las curvas, es posible que en alguna de ellas el robot se pierda y se pare. Esto se debe a que, como dec\u00edamos, todav\u00eda no le hemos dicho qu\u00e9 hacer si ambos sensores detectan superficie blanca a la vez. \u00a1Vamos a solucionarlo!</p>"},{"location":"3DBot/AAm_3DBot/#a_05_2-segunda-version-de-seguidor-de-linea","title":"A_05_2. Segunda versi\u00f3n de seguidor de l\u00ednea","text":"<p>Si ahora se pierde, es decir, si se encuentran ambos sensores en superficie blanca, empezar\u00e1 a girar en el \u00faltimo sentido que lo ha hecho justo antes de perderse. Para ello, cada vez que ejecute un movimiento debe memorizar que lo ha ejecutado.</p> <p>Vamos a utilizar la variable de texto \u201c\u00daltimo movimiento\u201d para memorizar cu\u00e1l ha sido el \u00faltimo movimiento realizado.</p> <p> <p> A_05_2_3DBot Acceder al programa</p> <p></p>"},{"location":"3DBot/AAm_3DBot/#a_06-control-por-bluetooth-1","title":"A_06. Control por Bluetooth 1","text":"<p>En esta actividad aprenderemos a controlar a nuestro robot con un dispositivo m\u00f3vil Android a trav\u00e9s de la funcionalidad Bluetooth del ESP32 STEAMakers.</p> <p>Para la gesti\u00f3n de las \u00f3rdenes en el m\u00f3vil disponemos de la aplicaci\u00f3n \u201cImagina 3dBot\u201d (descarga el apk e inst\u00e1lala en un dispositivo m\u00f3vil Android), hecha por Innova Didactic expresamente para nuestro robot:</p> <p> <p> Aplicaci\u00f3n Imagina 3DBot </p> <p></p> <p>Para decidir qu\u00e9 letras o n\u00fameros son los que hacen avanzar o girar, debemos consultar el apartado de informaci\u00f3n del aplicaci\u00f3n:</p> <p> <p> Informaci\u00f3n de la aplicaci\u00f3n Imagina 3DBot </p> <p></p> <p>Teniendo en cuenta esta informaci\u00f3n vamos a realizar un programa que lea los datos recibidos por Bluetooth y ejecute un movimiento en funci\u00f3n del dato recibido.</p> <p>Adem\u00e1s del bloque \u201cIniciar (Esclavo) Nombre\u201d, con el que identificaremos nuestro robot en las conexiones Bluetooth, vamos a leer los datos procedentes del Bluetooth con el bloque \u201cRecibir byte\u201d, tambi\u00e9n ubicado en el apartado \u201cComunicaciones \u2192 Bluetooth \u201d.</p> <p>Trabajar con lecturas en bytes nos obliga a leer los caracteres en c\u00f3digo ASCII. Este c\u00f3digo es una forma de codificar en n\u00fameros los caracteres y s\u00edmbolos del lenguaje. Tranquilo, porque Arduinoblocks dispone de un bloque para hacer la traducci\u00f3n inmediata, por lo que no deberemos dar ning\u00fan paso extra.</p> <p>Si la app indica que, cuando pulsas la flecha de movimiento hacia delante, env\u00eda por Bluetooth una U, por ejemplo, nosotros deberemos seleccionar una U en la programaci\u00f3n en Arduinoblocks mediante el siguiente bloque:</p> <p> <p> Bloque para traducir valor ASCII </p> <p></p> <p>El bloque para traducir los datos le\u00eddos en bytes (valores ASCII) se encuentra al final del men\u00fa \u201cText\u201d.</p> <p>El programa que debemos cargar en el robot queda de la siguiente manera:</p> <p> <p> A_06_3DBot Acceder al programa</p> <p></p> <p>Para vincular el dispositivo m\u00f3vil con nuestro robot activaremos la funci\u00f3n Bluetooth de nuestro dispositivo. Cuando aparezcan los diferentes dispositivos disponibles seleccionaremos nuestro robot seg\u00fan el nombre que hayamos escogido en el bloque \"Iniciar (Esclavo) Nombre\" e introducimos la contrase\u00f1a si hemos puesto alguna. Una vez aceptada ya deber\u00eda aparecer el robot en dispositivos vinculados.</p> <p>Ahora repetimos la operaci\u00f3n de conexi\u00f3n en la aplicaci\u00f3n Imagina 3dBot. Pulsa el bot\u00f3n \u201cConnect\u201d situado junto al t\u00edtulo de la misma y vuelve a seleccionar el nombre de tu robot.</p> <p>Con la aplicaci\u00f3n \u201cImagina 3dBot\u201d puedes controlar otros elementos del robot, como la velocidad de los motores, el zumbador, los 3 LED y el emisor IR, y leer los datos de los sensores de ultrasonidos, de luz, de temperatura, de IR y seguidor de l\u00ednea, del pulsador y de la entrada anal\u00f3gica A1.</p> <p>Tambi\u00e9n puedes controlar el robot por Bluetooth con Serial Bluetooth Terminal o con una aplicaci\u00f3n creada con App Inventor o Thunkable. A continuaci\u00f3n tienes un ejemplo desarrollado con App Inventor.</p>"},{"location":"3DBot/AAm_3DBot/#a_07-control-por-bluetooth-2","title":"A_07. Control por Bluetooth 2","text":"<p>Desarrollamos la aplicaci\u00f3n en base al documento 'Control del 3DBot per Bluetooth' publicado por Toni Hortal bajo licencia CC BY-SA NC.</p> <p>Las instrucciones generales son:</p> <ul> <li>Crea y sube el programa al ESP32 STEAMakers</li> <li>Crea la aplicaci\u00f3n con App Inventor</li> <li>Empareja el Bluetooth con tu dispositivo m\u00f3vil</li> <li>Conecta la aplicaci\u00f3n a tu dispositivo m\u00f3vil<ul> <li>o con MIT AI2 Companion (Android) (RECOMENDADO!) / AppInventor (iOS)</li> <li>o generando el APK</li> </ul> </li> <li>Pulsa en el bot\u00f3n Conectar de la aplicaci\u00f3n</li> <li>Selecciona el m\u00f3dulo Bluetooth</li> <li>Ya puedes utilizar la aplicaci\u00f3n para controlar el robot!!!!</li> </ul> <p>El programa en Arduinoblocks es:</p> <p> <p> A_07_3DBot Acceder al programa</p> <p></p> <p>Para el desarrollo de la app vamos a necesitar las im\u00e1genes que se ponen en los enlaces para descargarlas en formato png o formato svg por si queremos editarlas desde Inkscape.</p> <p> Archivo Descripci\u00f3n Formato png Archivo comprimido con todas las im\u00e1genes Formato svg Archivo que contiene los originales de giros y stop <p></p> <p>Una vez descargadas las im\u00e1genes y descomprimido el archivo .zip podemos subirlas mediante el bot\u00f3n \"Subir archivo...\" que tenemos en \"Medios\". En fase de dise\u00f1o la app nos va a quedar con este aspecto:</p> <p> <p> App en fase de dise\u00f1o </p> <p></p> <p>A\u00f1ade al \"Visor\" un cliente Bluetooth y un notificador (ambos componentes no visibles). A\u00f1ade al \"Visor\" todos los elementos de la lista \"Componentes\". El contenedor \"Tabular\" es de 3 columnas por 3 filas. A\u00f1ade al \"Visor\" un \"SelectorDeLista\" y hazlo invisible desmarcando su propiedad \"Visible\". En la imagen anterior esta propiedad a\u00fan lo hace visible.</p> <p>Asigna a cada bot\u00f3n su imagen correspondiente. Cambia la propiedad \"DispHorizontal\" de \"Screen1\" a \"Centro:3\".</p> <p>Modifica los textos de las etiquetas t\u00edtulo.</p> <p>Ahora cambiamos al modo \"Bloques\" para iniciar la programaci\u00f3n que hacemos paso a paso:</p> <ul> <li>Comenzamos por programar el comportamiento de la ventana \"Screen1\" as\u00ed como la conexi\u00f3n Bluetooth.</li> </ul> <p> <p> Bloques App ventana \"Screen1\" y Bluetooth Clic sobre la imagen para ver a tama\u00f1o completo</p> <p></p> <ul> <li>A continuaci\u00f3n vemos los bloques que definen el comportamiento de los botones.</li> </ul> <p> <p> Bloques App botones Clic sobre la imagen para ver a tama\u00f1o completo</p> <p></p> <p>A continuaci\u00f3n tenemos los ficheros de descarga:</p> <ul> <li>Descargar la app para Android .apk</li> <li>Descargar el proyecto .aia</li> </ul>"},{"location":"3DBot/AAm_3DBot/#a_08-robot-explorador-autonomo","title":"A_08. Robot explorador aut\u00f3nomo","text":"<p>En esta actividad equiparemos de \u201cojos\u201d al robot con el sensor de ultrasonidos HC-SR04 y haremos que funcione aut\u00f3nomamente explorando su entorno sin chocar. Para evitar el choque iremos utilizando diversas estrategias, de la m\u00e1s simple a la m\u00e1s complicada.</p> <p> <p> Sensor HC-SR04 en el robot </p> <p></p> <p>El bloque a usar se encuentra en el apartado \u201c3dBot\u201d de Arduinoblocks:</p> <p> <p> Bloque \"Distancia\" </p> <p></p>"},{"location":"3DBot/AAm_3DBot/#a_08_1-explorador-simple","title":"A_08_1. Explorador simple","text":"<p>Primero haremos un programa para que el robot siempre vaya hacia delante y que cuando encuentre un objeto, a menos de 20 cm, se detenga. Y si el objeto desaparece debe volver a avanzar.</p> <p> <p> A_08_1. Explorador simple Acceder al programa</p> <p></p>"},{"location":"3DBot/AAm_3DBot/#a_08_2-explorador-con-giros","title":"A_08_2. Explorador con giros","text":"<p>La segunda estrategia consistir\u00e1 en que, cuando se detenga, gire a la izquierda (el encoder est\u00e1 colocado en la rueda derecha) 90 grados y siga adelante. Para ello ser\u00e1 especialmente importante utilizar el encoder que hemos explicado en la actividad A_03. Control del robot con un encoder</p> <p>Hemos visto tambi\u00e9n en esa actividad que, para girar 90 grados en la derecha, basta con girar a la derecha durante 6 pasos (aproximadamente).</p> <p> <p> A_08_2. Explorador con giros Acceder al programa</p> <p></p>"},{"location":"3DBot/AAm_3DBot/#a_08_3-explorador-con-rotaciones","title":"A_08_3. Explorador con rotaciones","text":"<p>En lugar de la funci\u00f3n \u201cgirar\u201d, que s\u00f3lo mueve una rueda, se puede utilizarse la funci\u00f3n \u201crotar\u201d, en la que giran ambas ruedas en sentido contrario.</p> <p> <p> A_08_3. Explorador con rotaciones Acceder al programa</p> <p></p> <p>Si comparamos los dos \u00faltimos ejemplos, vemos que el n\u00famero de pasos necesario para rotar 90 grados no es igual que para girar 90 grados. Puedes probar con diferentes valores para ver los resultados.</p> <p>Tambi\u00e9n es muy importante tener en cuenta que s\u00f3lo disponemos de encoder en la rueda derecha, y que en los giros a la derecha \u00e9sta no se mueve. Por tanto, en este giro no podremos controlar el \u00e1ngulo girado. Dado que en las rotaciones s\u00ed se mueven ambas ruedas, aqu\u00ed s\u00ed podemos medir el \u00e1ngulo girado a la izquierda.</p> <p>Por \u00faltimo, se puede cambiar la distancia m\u00ednima a la que detecta un obst\u00e1culo.</p>"},{"location":"3DBot/AAm_3DBot/#a_08_4-explorador-para-laberinto","title":"A_08_4. Explorador para laberinto","text":"<p>En el programa anterior, \u00e9l robot s\u00f3lo puede esquivar obst\u00e1culos en una direcci\u00f3n, lo que provoca que cuando la \u00fanica direcci\u00f3n posible es la izquierda, el robot se pierde o vuelve por d\u00f3nde ha venido.</p> <p>Para evitarlo vamos a utilizar dos rotaciones distintas, una de 90 grados y otra de 180 grados. Estos dos movimientos los definimos, por comodidad, en las siguientes funciones:</p> <p> <p> A_08_4. Explorador para laberinto </p> <p></p> <p>Despu\u00e9s de esto, si vamos al apartado \u201cFunciones\u201d veremos las nuevas funciones creadas y preparadas para insertar en cualquier parte de nuestro programa.</p> <p>Adem\u00e1s, vamos a introducir nuevas condiciones que den a nuestro robot m\u00e1s herramientas a la hora de enfrentarse a obst\u00e1culos.</p> <p>Como antes el robot s\u00f3lo giraba a la izquierda, esto provocaba que, cuando la \u00fanica direcci\u00f3n posible estaba a la derecha, el robot se perd\u00eda o volv\u00eda por donde hab\u00eda venido.</p> <p>Para evitarlo vamos a decirle que si gira a la izquierda e inmediatamente vuelve a encontrar otro obst\u00e1culo que vuelva a girar a la izquierda, querr\u00e1 decir que realmente deb\u00eda haber girado hacia la derecha (es lo m\u00e1s probable). Teniendo en cuenta que acaba de dar un giro de 90 grados en la direcci\u00f3n equivocada, le diremos que gire 180 grados para ir en la direcci\u00f3n opuesta.</p> <p>Veremos en el programa que, para realizar esta condici\u00f3n explicada m\u00e1s efectiva, el robot tomar\u00e1 la decisi\u00f3n descrita, no s\u00f3lo cuando haya interpretado dos giros inmediatamente seguidos a la izquierda, sino tambi\u00e9n cuando los haya interpretado en menos de 800 ms, aunque en este tiempo s\u00ed haya avanzado brevemente en l\u00ednea recta.</p> <p> <p> A_08_4. Explorador para laberinto Acceder al programa</p> <p></p>"},{"location":"3DBot/AAm_3DBot/#a_09-control-con-nunchuk","title":"A_09. Control con Nunchuk","text":"<p>Para utilizar el joystick debemos saber sus valores. Podemos leerlos como hemos visto anteriormente en la consola. Como referencia saber que tanto en el eje X como en el eje Y, el valor en el punto central es 128, hacia un lado 0 y en el lado contrario es 255.</p> <p> <p> Valores joystick </p> <p></p> <p>Vamos a hacer un programa b\u00e1sico para poder controlar el robot hacia delante y atr\u00e1s, y girar sobre s\u00ed mismo:</p> <p> <p> A_09. Control con Nunchuk Acceder al programa</p> <p></p>"},{"location":"3DBot/AI_3DBot/","title":"Actividades 3DBot","text":"<p> <p> Robot 3DBot </p> <p></p>"},{"location":"3DBot/AI_3DBot/#a_01-control-de-un-motor-dc","title":"A_01. Control de un motor DC","text":"<p>La placa Imagina 3DBot ya lleva incorporado un driver o controlador de motores de CC. Con \u00e9l podemos realizar el control de 2 motores de corriente continua (CC) de hasta 2 A (amperios).</p> <p> <p> Posici\u00f3n de los conectores para motores </p> <p></p> <p>Seguramente habr\u00e1s observado que en el men\u00fa 3DBot existen algunas instrucciones espec\u00edficas para controlar el motor A o izquierdo, como la de la imagen adjunta. Cambiando la selecci\u00f3n del motor sirve tambi\u00e9n para controlar las mismas acciones para el motor B o derecho.</p> <p> <p> Bloque de control de motor del men\u00fa 3DBot </p> <p></p> <p>En el montaje del robot ve\u00edamos que, para conseguir un correcto funcionamiento con los bloques de Arduinoblocks, es necesario unir el motor izquierdo con el conector del motor A y el derecho con el conector B. Si los intercambiamos provocaremos que el robot se mueva en sentido contrario al programado.</p> <p>Realizar esta pr\u00e1ctica nos servir\u00e1 para saber si hemos montado y conectado correctamente los motores. Vamos a aprender a hacer funcionar el motor A, donde est\u00e1 conectado el motor izquierdo. Lo haremos mover hacia delante en el sentido de la marcha, hacia atr\u00e1s y lo pararemos.</p> <p> <p> A_01_1_3DBot Acceder al programa</p> <p></p> <p>Podemos observar en el funcionamiento el encendido de los LED que hay junto a los conectores para indicar el sentido de marcha del motor.</p> <p>Podemos hacer funcionar cualquiera de los dos motores, en cualquier sentido, detenerlos e incluso podemos ajustar la velocidad de rotaci\u00f3n.</p> <ul> <li>En \u201cVelocidad\u201d, valores muy peque\u00f1os no son capaces de poner en marcha el motor.</li> <li>cc Si introducimos el siguiente programa observaremos que el motor A va hacia delante a una velocidad r\u00e1pida durante 2 segundos, despu\u00e9s a una velocidad m\u00e1s lenta otros 2 segundos y finalmente se detiene y repite el proceso.</li> </ul> <p> <p> A_01_2_3DBot Acceder al programa</p> <p></p> <p>Hasta aqu\u00ed hemos visto que podemos controlar los motores de forma individual, pero para hacer funcionar al Imagina 3DBot existe un bloque a\u00fan m\u00e1s f\u00e1cil que se llama \u201cMover\u201d.</p> <p>Ahora estamos preparados para sacarnos el carn\u00e9 b\u00e1sico de \u201cEntrenador de robots\u201d.</p>"},{"location":"3DBot/AI_3DBot/#a_02-control-de-dos-motores-dc","title":"A_02. Control de dos motores DC","text":"<p>Con un solo bloque, \u201cMover\u201d, que encontramos en el apartado \u201c3dBot\u201d, podemos dar las \u00f3rdenes de avanzar, retroceder, girar, rotar sobre s\u00ed mismo y parar. Tambi\u00e9n podemos seleccionar la velocidad con tres opciones posibles.\u00a1As\u00ed de sencillo!</p> <p> <p> Bloque Mover </p> <p></p> <p>Vamos a realizar una serie de ejercicios para practicar todo lo que hemos aprendido hasta ahora y mezclar los temas de funciones, variables, etc.</p>"},{"location":"3DBot/AI_3DBot/#a_02_1-a-bailar","title":"A_02_1. \u00a1A bailar!","text":"<p>El siguiente programa hace que el robot rote sobre s\u00ed mismo constantemente:</p> <p> <p> A_02_1_3DBot Acceder al programa</p> <p></p>"},{"location":"3DBot/AI_3DBot/#a_02_2-creando-secuencias-de-movimientos","title":"A_02_2. \u00a1Creando secuencias de movimientos!","text":"<p>Vamos a empezar a estirar las piernas y las ruedas\u2026 con unos movimientos sencillos de calentamiento. Poco a poco haremos que estas secuencias dependan de est\u00edmulos externos y condiciones m\u00e1s elaboradas.</p> <p>El robot realizar\u00e1 los siguientes movimientos:</p> <ul> <li>Ir en l\u00ednea recta durante un segundo</li> <li>Girar a la izquierda durante un segundo</li> <li>Volver a ir en l\u00ednea recta durante otro segundo</li> <li>Girar a la derecha durante otro segundo</li> </ul> <p> <p> A_02_2_3DBot Acceder al programa</p> <p></p>"},{"location":"3DBot/AI_3DBot/#a_02_3-giro-y-semaforo-loco","title":"A_02_3. Giro y sem\u00e1foro loco","text":"<p>Empieza el espect\u00e1culo: LED, c\u00e1maras y\u2026 \u00a1Acci\u00f3n!</p> <p>Ahora nuestro robot rotar\u00e1 todo el rato a la izquierda, mientras sus 3 LED se encienden y apagan de forma secuencial. \u00a1Recuerda que el ritmo desenfrenado lo marcas t\u00fa!</p> <p>Ten en cuenta que el robot estar\u00e1 rotando a la izquierda todo el rato, independientemente de lo que hagan los LED, \u00a1ya que nunca le ordenamos que se pare!</p> <p> <p> A_02_3_3DBot Acceder al programa</p> <p></p>"},{"location":"3DBot/AI_3DBot/#a_02_4-movimientos","title":"A_02_4. Movimientos","text":"<p>Para poder conocer todos los sentidos de giro posibles que puede hacer el robot, te propongo que hagas los programas de los siguientes movimientos:</p> <ul> <li>Adelante y atr\u00e1s</li> </ul> <p> <p> Adelante y atr\u00e1s </p> <p></p> <ul> <li>Pivotar</li> </ul> <p> <p> Pivotar </p> <p></p> <ul> <li>Giros adelante</li> </ul> <p> <p> Giros adelante </p> <p></p> <ul> <li>Giros atr\u00e1s</li> </ul> <p> <p> Giros atr\u00e1s </p> <p></p> <ul> <li>Parar</li> </ul> <p> <p> Parar </p> <p></p> <p>En el programa siguiente se ejecutan todos los movimientos de forma indefinida a intervalos de tres segundos.</p> <p> <p> A_02_4_3DBot Acceder al programa</p> <p></p>"},{"location":"3DBot/AI_3DBot/#a_02_5-senalizando-la-marcha-atras","title":"A_02_5. Se\u00f1alizando la marcha atr\u00e1s","text":"<p>Este programa tiene dos partes fundamentales:</p> <ul> <li>Avance hacia delante con el piloto verde encendido.</li> <li>Marcha atr\u00e1s con el piloto rojo encendido y un silbato intermitente de se\u00f1alizaci\u00f3n de maniobra \"peligrosa\".</li> </ul> <p>Vamos a presentar una versi\u00f3n del programa en la que creamos dos funciones, y otra en la que se realiza el programa completo directamente en el bucle (sin funciones). La diferencia en este caso no es significativa, ya que no es un programa extenso ni se realizan muchas repeticiones.</p> <p>Por cierto, cuidado, porque lo peligroso puede acabar siendo el silbato\u2026 para los o\u00eddos.</p> <ul> <li>Programa con funciones</li> </ul> <p>Se definen dos funciones: \u201cir hacia delante\u201d e \u201cir hacia atr\u00e1s\u201d. El programa completo es el siguiente:</p> <p> <p> A_02_5_fun_3DBot Acceder al programa</p> <p></p> <ul> <li>Programa sin funciones</li> </ul> <p> <p> A_02_5_3DBot Acceder al programa</p> <p></p>"},{"location":"3DBot/AI_3DBot/#a_02_6-en-busca-de-la-luz","title":"A_02_6. En busca de la luz","text":"<p>Vamos a jugar algo con los niveles de luz. El robot Imagina 3DBot tiene un sensor de luz (LDR) que detecta las variaciones de iluminaci\u00f3n y las \"traduce\" a se\u00f1ales de tensi\u00f3n. En el apartado \"3dBot\" se encuentra el bloque que se encarga de programar este sensor.</p> <p> <p> Bloque sensor de luz </p> <p></p> <p>Adem\u00e1s, en el apartado \u201cL\u00f3gica\u201d encontramos un bloque que nos permite realizar comparaciones que NO dependen de operaciones matem\u00e1ticas directas, es decir, comparaciones de estados, valores, etc. Pulsando en la flecha dibujada en el bloque se abre un desplegable con diferentes opciones de comparaci\u00f3n:</p> <p> <p> Bloque comparar </p> <p></p> <p>Vamos a combinar este \u00faltimo bloque con funciones ya aprendidas para comparar un valor de iluminaci\u00f3n fijado por nosotros con el valor de iluminaci\u00f3n que lea el robot. En este caso, vamos a guardar los valores de iluminaci\u00f3n le\u00eddos en la variable \u201cluminosidad\u201d. Utilizaremos tambi\u00e9n el bloque \"Un n\u00famero\" del apartado \u201cMatem\u00e1ticas\u201d para hacer la comparaci\u00f3n.</p> <p>Si hay luz, \u00a1avanza adelante!</p> <p>En este caso vamos a hacer que, si el valor de luz detectado es superior a una cifra (en este ejemplo 300) el robot avance en l\u00ednea recta. Si el valor es menor, que permanezca parado.</p> <p>Puedes utilizarlo, por ejemplo, para que se mueva s\u00f3lo cuando se le enfoca con la linterna del m\u00f3vil en una habitaci\u00f3n con poca luz y se comporte como un robot tipo polilla.</p> <p> <p> A_02_6_3DBot Acceder al programa</p> <p></p> <p>Si despu\u00e9s de cargar el programa el robot se mueve todo el rato (aunque no se le enfoca con la linterna), querr\u00e1 decir que el nivel de luz de la sala es mayor que este 300 incluido en el programa. En este caso simplemente habr\u00e1 que aumentarlo hasta conseguir el resultado deseado.</p> <p>Por otro lado, s\u00f3lo cambiando el operando de la comparaci\u00f3n conseguiremos el efecto contrario: que el robot avance cuando haya poca luz y se detenga cuando el nivel suba:</p> <p> <p> A_02_6bis_3DBot Acceder al programa</p> <p></p>"},{"location":"3DBot/AI_3DBot/#a_03-control-del-robot-con-un-encoder","title":"A_03. Control del robot con un encoder","text":"<p>\u00bfQu\u00e9 es un encoder?</p> <p>Esta actividad requiere de la colocaci\u00f3n de una pieza impresa en 3D en el interior de la rueda derecha, tal y como se describe en el apartado correspondiente de Archivos de dise\u00f1o <p>En pocas palabras, un encoder es un dispositivo de detecci\u00f3n que proporciona una respuesta. Los encoders convierten el movimiento en una se\u00f1al el\u00e9ctrica que puede ser le\u00edda por alg\u00fan tipo de dispositivo de control en un sistema de control de movimiento, como por ejemplo nuestro robot. Nos permitir\u00e1 saber cu\u00e1nto avanza y retrocede nuestro robot.</p> <p>Hemos visto en el montaje del robot que en la rueda derecha existe un sensor \u00f3ptico con el fin de actuar como un encoder. La funci\u00f3n del encoder es convertir en se\u00f1ales el\u00e9ctricas el giro de la rueda, para as\u00ed saber cu\u00e1nto ha girado en cada momento.</p> <p>Como se aprecia en la siguiente figura, el sensor \u00f3ptico se activa cuando detecta un radio de nuestra rueda delante, y se desactiva cuando no hay nada (espacio entre radios).</p> <p> <p> Rueda encoder </p> <p></p> <p>Teniendo en cuenta que la rueda tiene, por ejemplo, 12 radios, cuando hayamos contado 12 pulsos significar\u00e1 que la rueda ha dado una vuelta completa.</p> <p>Podemos utilizar esta funcionalidad para controlar distancias y giros en el 3DBot. Lo hacemos con el bloque \u201cEsperar \u2026 pasos\u201d que se encuentra en el apartado \u201c3dBot\u201d. A cada pulso recibido se le llama \"paso\". Siguiendo el ejemplo de antes, una vuelta de rueda completa ser\u00e1n 12 \"pasos\".</p> <p> <p> Bloque Esperar \u2026 pasos </p> <p></p> <p>Se puede comprobar experimentalmente que, aproximadamente, para dar un giro de 90 grados hacia la izquierda, la rueda derecha debe mover 4 pasos (pasan 4 radios de la rueda por delante del sensor \u00f3ptico). De esta forma podemos decirle a nuestro robot que gire 90 grados, 180 grados, etc.</p>"},{"location":"3DBot/AI_3DBot/#a_03_1-lectura-basica-del-encoder","title":"A_03_1. Lectura b\u00e1sica del encoder","text":"<p>En este primer programa simplemente vamos a leer el valor anal\u00f3gico del pin A1 al que est\u00e1 conectado el sensor y convertirlo a valor Booleano. El sensor lo activamos moviendo la rueda derecha y los resultados los vemos en la Consola.</p> <p> <p> A_03_1_3DBot Acceder al programa</p> <p></p>"},{"location":"3DBot/AI_3DBot/#a_03_2-recorrido-programado-contando-pasos","title":"A_03_2. Recorrido programado contando \u201cpasos\u201d","text":"<p>El programa funciona de forma similar a los juegos con LED utilizando la funci\u00f3n \u201cEsperar\u2026 pasos\u201d. Aqu\u00ed, el robot mantendr\u00e1 la \u00faltima direcci\u00f3n programada hasta que se d\u00e9 el n\u00famero de pasos descrito.</p> <p> <p> A_03_2_3DBot Acceder al programa</p> <p></p>"},{"location":"3DBot/AI_3DBot/#a_04-control-del-robot-por-mando-ir","title":"A_04. Control del robot por mando IR","text":"<p>La placa Imagina 3DBot lleva incorporado un diodo receptor de infrarrojos. Se encuentra junto a los sensores de temperatura y luz.</p> <p> <p> Posici\u00f3n del recptor de IR </p> <p></p> <p>Pasamos a controlar el robot en tiempo real. Vamos a utilizar inicialmente el mando de Keyestudio, que dispone de un bloque espec\u00edfico en Arduinoblocks, lo que hace que la programaci\u00f3n sea muy r\u00e1pida y sencilla.</p> <p>Ampliaci\u00f3n de informaci\u00f3n sobre infrarrojos</p> <p>Posteriormente aprenderemos a utilizar cualquier mando, incluso el de la tele, que siempre est\u00e1 a mano.</p> <p>Y finalmente haremos un programa algo m\u00e1s avanzado en el que no s\u00f3lo cambiaremos la direcci\u00f3n del robot, sino tambi\u00e9n su velocidad.</p>"},{"location":"3DBot/AI_3DBot/#a_04_1-control-de-direccion","title":"A_04_1. Control de direcci\u00f3n","text":"<p>Para este ejemplo vamos a utilizar el mando de infrarrojos (IR) de Keyestudio. Concretamente utilizaremos las teclas de direcci\u00f3n para mover el robot en las 4 direcciones. Adem\u00e1s, con el bot\u00f3n central de \u201cOK\u201d haremos que se detenga. Para ello necesitamos 2 nuevos bloques:</p> <ul> <li>en el apartado \u201c3dBot\u201d tenemos el bloque \u201cReceptor de IR (Texto HEX)\u201d, que lee los datos procedentes de un mando con infrarrojos:</li> </ul> <p> <p> Bloque receptor de IR </p> <p></p> <ul> <li>en el apartado \u201c3dBot\u201d encontramos el bloque del mando de Keyestudio, en el que, pulsando en el desplegable, podemos seleccionar cualquiera de sus teclas:</li> </ul> <p> <p> Bloque del mando de Keyestudio </p> <p></p> <p>IMPORTANTE: tienes que cambiar la versi\u00f3n del comando a v2</p> <p>Utilizaremos el bloque de comparaci\u00f3n del apartado \u201cTexto\u201d que dice \u201cigual a\u201d para comparar el dato le\u00eddo por el sensor IR con el dato seleccionado por nosotros para una funci\u00f3n determinada.</p> <p>Con un condicional \u201csi\u2026 hacer\u2026\u201d decidiremos qu\u00e9 acci\u00f3n tomar.</p> <p>En la variable \"Mando\" guardamos los valores le\u00eddos por el receptor infrarrojo, para as\u00ed compararlos con los valores correspondientes al mando. El programa resultante lo podemos ver a continuaci\u00f3n:</p> <p> <p> A_04_1. Control de direcci\u00f3n Acceder al programa</p> <p></p>"},{"location":"3DBot/AI_3DBot/#a_04_2-control-de-direccion-y-velocidad","title":"A_04_2. Control de direcci\u00f3n y velocidad","text":"<p>Ampliamos el ejercicio anterior para introducir el control de velocidad con el mando de Keyestudio.</p> <p>En el apartado \u201c3dBot\u201d encontraremos el bloque para controlar la direcci\u00f3n de cada motor y su velocidad.</p> <p> <p> Bloque control direcci\u00f3n y velocidad </p> <p></p> <p>La velocidad del motor se controla con el dato num\u00e9rico que hay en la parte derecha del bloque. Su velocidad aumenta proporcionalmente al n\u00famero incluido, siendo 0 motor parado y 255 motor a su m\u00e1xima velocidad. Aqu\u00ed podemos incluir una variable para que esa velocidad provenga de una lectura del mando IR, por ejemplo.</p> <p>En el desplegable, junto a la palabra \u201cMotor\u201d, seleccionamos qu\u00e9 motor queremos controlar.</p> <p> <p> Bloque control direcci\u00f3n y velocidad. Motor </p> <p></p> <p>Y en el desplegable siguiente escogemos el sentido de giro:</p> <p> <p> Bloque control direcci\u00f3n y velocidad. Giro </p> <p></p> <p>Una vez conocidos los nuevos elementos, vamos a realizar el programa. Para ello, definimos las variables que representan a los movimientos que podr\u00e1 efectuar el robot. Como dec\u00edamos, la velocidad la tomaremos de una variable \u201cVelocidad\u201d que asignaremos en el bucle del programa.</p> <p>Funciones <ul> <li>\u201cAdelante\u201d: con los 2 motores girando en el sentido de avance, hacemos que se mueva en l\u00ednea recta:</li> </ul> <p> <p> Funci\u00f3n adelante </p> <p></p> <ul> <li>\"Giro izquierda\": lo conseguimos avanzando con la rueda derecha y manteniendo la izquierda parada:</li> </ul> <p> <p> Funci\u00f3n giro izquierda </p> <p></p> <ul> <li>\"Giro derecha\": lo conseguimos avanzando con la rueda izquierda y manteniendo la derecha parada:</li> </ul> <p> <p> Funci\u00f3n giro derecha </p> <p></p> <ul> <li>\u201cParar\u201d: lo hacemos seleccionando en ambos motores la opci\u00f3n \u201cParar\u201d.</li> </ul> <p> <p> Funci\u00f3n parar </p> <p></p> <p>Bucle <p>Primero leemos los datos recibidos por el receptor IR y los guardamos en la variable \u201cMando\u201d. A continuaci\u00f3n, diferenciamos los datos recibidos en 2 tipos:</p> <ul> <li>Datos para el cambio de velocidad</li> <li>Datos para el cambio de direcci\u00f3n</li> </ul> <p>Los datos para el cambio de velocidad los guardamos en la variable num\u00e9rica \u201cVelocidad\u201d, y los datos para el cambio de sentido de giro los guardamos en la variable de texto \u201cGiro\u201d.</p> <p>Como hemos visto en la definici\u00f3n de las funciones, la variable \u201cVelocidad\u201d la insertamos en los bloques de movimiento de los motores, dentro de la definici\u00f3n de las funciones.</p> <p>Por \u00faltimo, establecemos las condiciones para que, dependiendo del valor de la variable Giro, vaya en la direcci\u00f3n deseada.</p> <p> <p> A_04_2_3DBot Acceder al programa</p> <p></p>"},{"location":"3DBot/AI_3DBot/#a_04_3-lectura-de-los-codigos-de-las-teclas-desde-un-mando-ir-cualquiera","title":"A_04_3. Lectura de los c\u00f3digos de las teclas desde un mando IR cualquiera","text":"<p>Primero debemos ver qu\u00e9 c\u00f3digo nos env\u00eda cada bot\u00f3n del mando que vamos a utilizar. Lo que vamos a hacer es presionar el bot\u00f3n del mando, leer el dato enviado e imprimirlo en la pantalla del ordenador. De ah\u00ed ya podemos copiarla para nuestro futuro programa.</p> <p>Simplemente hay que recordar que para visualizar datos en la pantalla es necesario realizar el env\u00edo de datos al ordenador cada cierto tiempo (no constantemente) para no saturar la comunicaci\u00f3n. Veamos c\u00f3mo queda el programa:</p> <p> <p> A_04_3_3DBot Acceder al programa</p> <p></p> <p>Dependiendo de qu\u00e9 bot\u00f3n se pulse, aparecer\u00e1 un valor u otro. Es importante tener en cuenta que si no accionamos ning\u00fan pulsador lo habitual ser\u00e1 recibir un 0. Obtendr\u00e1s algo as\u00ed, despu\u00e9s de conectarte a la \u201cConsola serie\u201d:</p> <p> <p> A_04_3_3DBot </p> <p></p> <p>La asociaci\u00f3n de c\u00f3digos, teclas y movimientos es:</p> <p>Flecha arriba: E0E006F9 - Adelante Fleccha izquierda: E0E0A659 - Giro izquierda Flecha abajo: E0E08679 - Atr\u00e1s Flecha derecha: E0E046B9 - Giro derecha Bot\u00f3n OK: E0E016E9 - Parar</p>"},{"location":"3DBot/AI_3DBot/#a_04_4-control-del-robot-con-un-mando-ir-cualquiera","title":"A_04_4. Control del robot con un mando IR cualquiera","text":"<p>Utilizando los c\u00f3digos le\u00eddos con el programa anterior vamos a realizar un sistema de control de nuestro robot por mando IR. El programa es exactamente igual que el del ejercicio anterior, s\u00f3lo que ahora comparemos con estos nuevos c\u00f3digos.</p> <p>En este caso vamos a guardar las lecturas del sensor IR en una variable llamada \u201cLectura mando\u201d. Da igual el nombre, puedes poner lo que quieras.</p> <p> <p> A_04_4_3DBot Acceder al programa</p> <p></p>"},{"location":"3DBot/Av_3DBot/","title":"Actividades 3DBot","text":"<p> <p> Robot 3DBot </p> <p></p> <p>En esta secci\u00f3n realizaremos ejercicios con elementos IoT, interactuar con Telegram, Bluetooth, mando Nunchuk. Todo ello basado en:</p> <p>Manual 3DBot de Innova Didactic</p> <p>Tutorial de Pedro Ruiz Ejemplos 3DBot + ESP32 STEAMakers</p> <p>Se recomienda revisar los contenidos en actividades avanzadas con la placa Imagina 3DBot antes de afrontar esta actividad con el robot.</p>"},{"location":"3DBot/Av_3DBot/#telegram-movimientos-3dbot","title":"Telegram. Movimientos 3DBot","text":"<p>Ejemplo basado en el tutorial de Pedro Ruiz Ejemplos 3DBot + ESP32 STEAMakers.</p> <p>Lo que haremos ser\u00e1 controlar los movimientos del robot mediante un bot de Telegram.</p> <p>Comenzamos por configurar la conexi\u00f3n WiFi y el API Token de Telegram.</p> <p> <p> Telegram. Movimientos 3DBot </p> <p></p> <p>Definimos las siguientes funciones con paso de valor desde una variable:</p> <p> <p> Telegram. Movimientos 3DBot </p> <p></p> <p>Finalmente configuramos el evento de Telegram 'Nuevo mensaje recibido' y ya podemos subir el programa a la placa.</p> <p> <p> Telegram. Movimientos 3DBot Clic sobre la imagen para ampliarla Acceder al programa</p> <p></p>"},{"location":"3DBot/Av_3DBot/#telegram-movimientos-y-control-de-consumo-3dbot","title":"Telegram. Movimientos y control de consumo 3DBot","text":"<p>Ejemplo basado en el tutorial de Pedro Ruiz Ejemplos 3DBot + ESP32 STEAMakers.</p> <p>Lo que haremos ser\u00e1 controlar los movimientos del robot y consultar los datos de sus sensores tanto internos como e la placa Imagina 3DBot mediante un bot de Telegram.</p> <p>Partimos del ejemplo anterior y comenzamos por configurar la conexi\u00f3n WiFi y el API Token de Telegram.</p> <p> <p> Telegram. Movimientos 3DBot </p> <p></p> <p>Las funciones y bloques del ejemplo anterior los dejamos como est\u00e1n.</p> <p>Modificamos el mensaje de ayuda para que tenga estos textos:</p> <p>/ayuda o /help: ordenes disponibles; /adelante /atras /izda /dcha /Rizda para rotar a la izquierda /Rdcha para rotar a la derecha  /Gizda para giro atras izquierda /Gdcha para giro atras derecha /internos para consultar valores de sensores internos /distancia da la distancia a objeto /luz da el valor de luminosidad /ambiente da la temperatura ambiente</p> <p>A\u00f1adir la funci\u00f3n y bloques que vemos seguidamente.</p> <p> <p> Telegram. Movimientos y control de consumo 3DBot Acceder al programa</p> <p></p>"},{"location":"3DBot/Av_3DBot/#mqtt-control-del-3dbot-con-iot","title":"MQTT. Control del 3DBot con IoT","text":"<p>En Teor\u00eda b\u00e1sica de IoT tienes disponible informaci\u00f3n mas extensa sobre el tema de IoT y MQTT.</p> <p>MQTT es un protocolo de comunicaci\u00f3n entre diferentes dispositivos (clientes, nodos) a trav\u00e9s de un servidor (broker), mediante la publicaci\u00f3n/suscripci\u00f3n de mensajes asociados a temas (topics).</p> <p>Es muy ligero, consume muy pocos recursos. Esto lo hace id\u00f3neo para trabajar la IoT con sensores y dispositivos de baja potencia. El uso de entornos gr\u00e1ficos de programaci\u00f3n permite trabajar con MQTT de forma creativa a muchos niveles.</p> <p>El bloque 'Iniciar' de la categor\u00eda 'Comunicaciones - WiFi /IoT - MQTT Client' permite definir los par\u00e1metros de la comunicaci\u00f3n:</p> <p> <p> MQTT. Control del 3DBot con IoT </p> <p></p> <p>Para poder trabajar con estos elementos utilizamos:</p> <ul> <li>una placa ESP32 STEAMakers que enviar\u00e1 datos a un broker MQTT</li> <li>un servidor MQTT que puede ser p\u00fablico, gratuito y sin configuraci\u00f3n como mqtt.eclipseprojects.io o broker.hivemq.com o bien uno propio creado con mosquitto</li> <li>un dispositivo m\u00f3vil que se suscribir\u00e1 a los temas publicados a trav\u00e9s de una aplicaci\u00f3n m\u00f3vil. Existen muchas aplicaciones, unas mas completas que otras, y veremos algunas en las actividades que vamos a hacer sobre el tema, pero para mi la mas completa es IoT MQTT Panel.</li> </ul> <p>Debemos tener en cuenta que los servidores MQTT p\u00fablicos gratuitos no son seguros y cualquiera puede suscribirse a nuestros mensajes y publicar en ellos, y en consecuencia podr\u00e1n enviar \u00f3rdenes. Se recomienda utilizar estos brokers solamente en sistemas educativos y de pruebas"},{"location":"3DBot/Av_3DBot/#mqtt_aav1-generar-datos-y-publicar-temas","title":"MQTT_AAv1. Generar datos y publicar temas","text":"<p>Para explicar un poco el funcionamiento b\u00e1sico vamos a hacer que la placa ESP32 STEAMakers genere un dato (un n\u00famero entre 1 y 100) y lo vamos a publicar en broker.hivemq.com para visualizarlo en tres aplicaciones diferentes.</p> <p>En este primer ejemplo publica el topic la placa y se suscribe la aplicaci\u00f3n.</p> <p>Vamos a comenzar por instalar en un smartphone las siguientes apps:</p> <p> <p> MQTT_AAv1. Apps IoT MQTT Panel -- MyMQTT -- MQTT Dashboard</p> <p></p> <p>Vamos a comenzar por crear el programa siguiente y subirlo a la placa:</p> <p> <p> MQTT_AAv1 Acceder al programa</p> <p></p> <p>MUY IMPORTANTE: el Client ID de Arduinoblocks NO puede ser el mismo que el Cliente Id escrito en la aplicaci\u00f3n, ya que un broker NO puede tener dos identificadores de cliente iguales. <p>A continuaci\u00f3n vamos a ver resultados en las tres APPs citadas.</p> <ul> <li>MyMQTT <p>Comenzamos por configurar la APP y conectarnos al broker:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>Nos suscribimos al topic establecido en el programa:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>Una vez suscritos y configurada la conexi\u00f3n el topic queda habilitado:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>El panel o tablero (dashboard) comienza a recibir los n\u00fameros:</p> <p> <p> MQTT_AAv1 </p> <p></p> <ul> <li>MQTT Dashboard <p>Lo primero que debemos hacer es a\u00f1adir un broker:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>Ahora introducimos los datos del broker y lo salvamos:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>Ya tenemos el broker. Si entramos en el mismo ya podemos conectarnos mediante el bot\u00f3n 'Connect' y poder continuar:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>Configurado el broker y conectados al mismo, ya podemos suscribirnos al topic mediante el bot\u00f3n 'Subscriber':</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>Realizada la suscripci\u00f3n veremos algo como:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>Ya podemos ver como se reciben los datos:</p> <p> <p> MQTT_AAv1 </p> <p></p> <ul> <li>IoT MQTT Panel <p>Con las APPs anterior vemos los datos de forma num\u00e9rica o textual. ahora vamos a ver esos mismos datos pero a\u00f1adiendo objetos al panel.</p> <p>Vamos a describir los pasos a seguir con IoT MQTT Panel. La primera vez que iniciamos la APP se nos presenta la siguiente pantalla:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>Indicando que debemos establecer un nombre, un broker, el puerto y a\u00f1adir un panel:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>El 'Client ID' lo puedes dejar en blanco (la aplicaci\u00f3n generar\u00e1 uno aleatoriamente) o escribir uno.</p> <p>MUY IMPORTANTE: este Client ID NO puede ser el mismo que el Cliente Id escrito en Arduinoblocks, ya que un broker NO puede tener dos identificadores de cliente iguales. <p>El panel de conexiones mostrar\u00e1 las que tengamos configuradas:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>Si todo ha ido bien, ver\u00e1s un icono en forma de nube de color naranja en la esquina superior derecha, que indica que la aplicaci\u00f3n se ha conectado correctamente al broker.</p> <p>Si, en cambio, ves un icono en forma de nube de color gris tachado, revisa los datos de la conexi\u00f3n.</p> <p>Pulsando sobre la nube naranja accedemos al dashboard a\u00f1adido anteriormente:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>Pulsa el bot\u00f3n \"ADD PANEL\" y se mostrar\u00e1 una lista de los 21 artilugios disponibles, que son:</p> <ul> <li>Button</li> <li>Switch</li> <li>Slider</li> <li>Text Input</li> <li>Text Log</li> <li>Node Status</li> <li>Combo Box</li> <li>Radio Buttons</li> <li>LED Indicator</li> <li>Multi-State Indicator</li> <li>Progress</li> <li>Gauge</li> <li>Color Picker</li> <li>Date &amp; Time Picker</li> <li>Line Graph</li> <li>Bar Graph</li> <li>Chart</li> <li>Image</li> <li>Barcode Scanner</li> <li>URI Launcher</li> <li>Layout Decorator</li> </ul> <p>Como ejemplo a\u00f1adiremos un Progress (barra de progreso) y un Gauge o indicador de aguja, como se muestra en las siguientes im\u00e1genes:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p>A continuaci\u00f3n vemos una captura recibiendo datos:</p> <p> <p> MQTT_AAv1 </p> <p></p> <p> Icono Significado El icono naranja de la nube (parte superior derecha) indica que la conexi\u00f3n con el broker es correcta Podemos desconectarnos pulsando el icono naranja, que cambiar\u00e1 a gris o conectarnos si est\u00e1 en gris Si el icono parpadea entre estos dos significa que nuestro Cliente ID est\u00e1 repetido en el broker y, por tanto, debemos cambiarlo por otro <p></p>"},{"location":"3DBot/Av_3DBot/#mqtt_aav2-control-del-led-verde-desde-la-aplicacion","title":"MQTT_AAv2. Control del LED verde desde la aplicaci\u00f3n","text":"<p>Vamos a controlar desde la aplicaci\u00f3n IoT MQTT Panel del m\u00f3vil el LED verde (D3 / IO25) de la placa Imagina 3DBot.</p> <p>Utilizamos:</p> <ul> <li>un dispositivo m\u00f3vil que generar\u00e1 datos y publicar\u00e1 temas a trav\u00e9s de una aplicaci\u00f3n m\u00f3vil</li> <li>un servidor MQTT p\u00fablico, gratuito y sin configuraci\u00f3n</li> <li>una placa ESP32 STEAMakers que se suscribir\u00e1 a los temas publicados y generar\u00e1 acciones</li> </ul> <p>En este ejemplo publica el topic la aplicaci\u00f3n y se suscribe la placa.</p> <p>Comenzamos por dirigirnos a la p\u00e1gina principal de la aplicaci\u00f3n (donde se muestran las conexiones). Si no estamos ah\u00ed podemos escoger \"All Connections\" del men\u00fa que nos muestran las tres l\u00edneas de la esquina superior izquierda.</p> <p> <p> MQTT_AAv2 </p> <p></p> <p>Pulsamos sobre 'Pruebas 3dbot\" y sobre los tres puntos a la derecha de nube, se despliega un men\u00fa en el que vamos a escoger \"Add a new dashboard\":</p> <p> <p> MQTT_AAv2 </p> <p></p> <p>Cumplimentamos los campos como vemos a continuaci\u00f3n y pulsamos sobre el bot\u00f3n \"CREATE\":</p> <p> <p> MQTT_AAv2 </p> <p></p> <p>Entra en el nuevo panel pulsando el bot\u00f3n en la parte inferior y despu\u00e9s pulsa el bot\u00f3n \"ADD PANEL\".</p> <p> <p> MQTT_AAv2 </p> <p></p> <p>Selecciona un artilugio Button para encender el LED y otro para apagar el LED:</p> <p> <p> MQTT_AAv2 </p> <p></p> <p>La situaci\u00f3n de la aplicaci\u00f3n es:</p> <p> <p> MQTT_AAv2 </p> <p></p> <p>Abre un nuevo proyecto en Arduinoblocks y sube el programa siguiente a la placa (recuerda que el Cliente Id del blog MQTT Iniciar NO puede ser el mismo que el del aplique IoT MQTT Panel): <p> <p> MQTT_AAv2 Acceder al programa</p> <p></p>"},{"location":"3DBot/Av_3DBot/#mejora-de-mqtt_aav2","title":"Mejora de MQTT_AAv2","text":"<p>Con el \u00e1nimo de ampliar un poco el manejo de la aplicaci\u00f3n vamos a a\u00f1adirle algunos elementos a la misma sin cambiar nada en el programa que cargamos en la placa ESP32 STEAMakers. Comenzamos por a\u00f1adir un \"LED indicator\", que simplemente nos va a mostrar el estado del diodo LED verde. Establecemos la configuraci\u00f3n que vemos en la imagen siguiente:</p> <p> <p> Mejora MQTT_AAv2 </p> <p></p> <p>El segundo elemento que vamos a a\u00f1adir es un \"Switch\" que configuramos de la forma que vemos a continuaci\u00f3n:</p> <p> <p> Mejora MQTT_AAv2 </p> <p></p> <p>Al activar \"Use icon switch\" se permite configurar los colores de encendido y apagado y adem\u00e1s pulsando sobre las \u00e1reas se\u00f1aladas se nos despliega una ventana donde podemos elegir el icono apropiado de entre los disponibles.</p> <p> <p> Mejora MQTT_AAv2 </p> <p></p> <p>En la aplicaci\u00f3n el funcionamiento es el que vemos en la animaci\u00f3n siguiente:</p> <p> <p> Mejora MQTT_AAv2 </p> <p></p>"},{"location":"3DBot/Av_3DBot/#mqtt_aav3-control-del-robot","title":"MQTT_AAv3. Control del robot","text":"<p>Comenzamos por a\u00f1adir un nuevo Dashboard a nuestro panel de control:</p> <p> <p> MQTT_AAv3 </p> <p></p> <p>A\u00f1adimos como primer elemento un \"Button\" que configuramos de la forma que vemos a continuaci\u00f3n:</p> <p> <p> MQTT_AAv3 </p> <p></p> <p>Utilizando la herramienta de copia que est\u00e1 junto al signo de a\u00f1adir panel copiamos el anterior y lo editamos para crear el bot\u00f3n atr\u00e1s. En nuestro caso le cambiamos el color y el icono y obligato8riamente le asignamos su valor en \"Payload\". Seguimos haciendo esta operaci\u00f3n hasta a\u00f1adir todos los botones necesarios y nos quedar\u00e1 una configuraci\u00f3n como la siguiente:</p> <p> <p> MQTT_AAv3 </p> <p></p> <p>El programa lo vemos en la imagen siguiente:</p> <p> <p> MQTT_AAv3 Acceder al programa</p> <p></p>"},{"location":"3DBot/Av_3DBot/#mejora-de-mqtt_aav3","title":"Mejora de MQTT_AAv3","text":"<p>Una vez comprobado que la actividad \"MQTT_AAv3. Control del robot\" funciona correctamente vamos a hacer que la placa envie a la aplicaci\u00f3n del m\u00f3vil un mensaje con la indicaci\u00f3n del movimiento que se est\u00e1 realizando.</p> <p>En la aplicaci\u00f3n a\u00f1adimos un panel de tipo \"Text Log\" que configuramos como vemos a continuaci\u00f3n:</p> <p> <p> Mejora MQTT_AAv3 </p> <p></p> <p>En cada movimiento, tras realizar el mismo se actualiza el valor de la variable de texto 'estado' que es donde escribimos el movimiento que se est\u00e1 realizando. A continuaci\u00f3n vemos parte de estos movimientos y valor de dicha variable.</p> <p> <p> Mejora MQTT_AAv3 </p> <p></p> <p>El programa lo vemos en la imagen siguiente:</p> <p> <p> MQTT_AAv3 Acceder al programa</p> <p></p>"},{"location":"3DBot/Av_3DBot/#iot-con-thingspeak","title":"IoT con ThingSpeak","text":"<p>Vamos a crear unas actividades de IoT con el robot para subir datos al broker ThingSpeak mientras el robot va siguiendo la l\u00ednea negra, tal y como vimos en la A_05_2. Segunda versi\u00f3n de seguidor de l\u00ednea.</p>"},{"location":"3DBot/Av_3DBot/#aav4_iot-con-3dbot-modo-dato-a-dato","title":"AAv4_IoT con 3DBot: modo dato a dato","text":"<p>En esta actividad vamos a crear un ejemplo en el que subimos los datos a ThinSpeak de uno en uno. Recuperamos el ejemplo para que el robot se mueva por el circuito y a\u00f1adimos funciones para leer los sensores y subir datos a la nube.</p> <p>En los ejemplos del apartado Subir datos a Internet dentro de las actividades avanzadas con la placa Imagina tenemos descritos los pasos a seguir para subir datos a ThingSpeak. Trabajaremos tambi\u00e9n con un canal y variables ampliando a alguna mas que vemos seguidamente.</p> <p>Se procede siempre a configurar la conexi\u00f3n WiFi y la inicializaci\u00f3n de MQTT en el bucle 'Inicializar'. A continuaci\u00f3n establecemos los movimientos del robot y finalmente creamos la funci\u00f3n 'subir datos' que enviar\u00e1 uno a uno los valores medidos a la nube. El retardo establecido de 2000 ms es posible porque las pruebas se realizan en una cuenta de pago. A continuaci\u00f3n tenemos el programa que soluciona la actividad.</p> <p> <p> MQTT_AAv4 Acceder al programa</p> <p></p> <p>La imagen siguiente muestra algunos resultados obtenidos:</p> <p> <p> MQTT_AAv4 </p> <p></p>"},{"location":"3DBot/Av_3DBot/#aav5_iot-con-3dbot-publicacion-multiple","title":"AAv5_IoT con 3DBot: publicacion multiple","text":"<p>En Arduinoblocks se han creado unos nuevos bloques que permiten publicar m\u00faltiples valores v\u00eda MQTT con ThingSpeak. Ahora se permite enviar varios datos a la vez sin tener en cuenta las restricciones de tiempo m\u00ednimo entre publicaciones impuestas por el broker. Es decir, se suben todos los datos al mismo tiempo debiendose mantener el tiempo entre subidas.</p> <p>En la imagen podemos observar la nueva forma que toma la funci\u00f3n 'subir datos' con estos nuevos bloques.</p> <p> <p> MQTT_AAv5 </p> <p></p> <p>El programa es el siguiente:</p> <p> <p> MQTT_AAv5 Acceder al programa</p> <p></p> <p>La imagen siguiente muestra algunos resultados obtenidos:</p> <p> <p> MQTT_AAv5 </p> <p></p>"},{"location":"3DBot/archivosFab/","title":"Estructura 3DBot","text":"<p>Aqu\u00ed vamos a informar y poner enlaces de descarga de los ficheros actualizados para imprimir en 3D o cortar con laser la estructura necesaria para realizar el montaje del robot.</p> <p>Tambi\u00e9n vamos a hacer lo mismo pero con los ficheros correspondientes para impresi\u00f3n 3D del accesorio encoder para las ruedas del robot.</p>"},{"location":"3DBot/archivosFab/#estructura","title":"Estructura","text":"<p>El aspecto de las piezas 3D necesarias para el montaje de la estructura las vemos en la imagen siguiente:</p> <p> <p> Piezas para impresi\u00f3n 3D </p> <p></p> <p>La estructura montada sin vitaminas (componentes) queda as\u00ed:</p> <p> <p> Estructura montada </p> <p></p> <p>A continuaci\u00f3n se dan los enlaces para descargar los archivos de impresi\u00f3n:</p> <ul> <li>Aqu\u00ed est\u00e1 el archivo stl con todas las piezas listo para laminar e imprimir.</li> </ul> <p> <p> Piezas impresas </p> <p></p> <ul> <li>Un archivo comprimido con las piezas individuales por si necesitamos imprimir alguna de manera individual. En el nombre del archivo se indica el n\u00famero de piezas necesario.</li> </ul> <p> Pieza Archivo Pieza Archivo 3DBot_basex1.stl 3DBot_soporte_electronicax1.stl 3DBot_tope_posterior_pbx1.stl 3DBot_tope_delantero_pbx1.stl 3DBot_soporte_motorx2.stl 3DBot_bola_loca_soportex1.stl 3DBot_Tx10.stl 3DBot_hx1.stl <p></p> <ul> <li>Archivo stl con un complemento para el 3DBot, una bandeja.</li> </ul> <p> <p> Complemento bandeja </p> <p></p> <p>En la imagen siguiente vemos la posici\u00f3n de la bandeja sobre la estructura.</p> <p> <p> Estructura con bandeja </p> <p></p> <p>Otra opci\u00f3n para obtener estas piezas (excepto la bandeja) es el corte l\u00e1ser dado que est\u00e1n dise\u00f1adas para ello. El archivo que se enlaza a continuaci\u00f3n es para utilizar en la cortadora l\u00e1ser Oku Desk de NomadTech que dispone de una versi\u00f3n propia de Inkscape con la extensi\u00f3n para la generaci\u00f3n de GCodes. Desafortunadamente no tiene en su zona de descargas una versi\u00f3n para Linux. L\u00f3gicamente se puede utilizar para llevar los trayectos en Inkscape con alguna otra extensi\u00f3n para generaci\u00f3n de GCode como JTech <ul> <li>Enlace al archivo vectorial. Estas son las piezas que se utilizan en el montaje versi\u00f3n corte en madera.</li> </ul> <p> <p> Archivo vectorial de corte l\u00e1ser Clica sobre la imagen para ampliarla  </p> <p></p>"},{"location":"3DBot/archivosFab/#encoder","title":"Encoder","text":"<p>En este apartado vamos a mostrar y enlazar los archivos de dise\u00f1o de una rueda impresa en 3D similar a la de la vista en el montaje de la versi\u00f3n impresa y tambi\u00e9n los de un accesorio para el encoder \u00f3ptico que se adapte a la rueda que viene con el nuevo kit de 3DBot.</p> <p>El aspecto de la rueda impresa en la que los radios hacen de encoder es:</p> <p> <p> Rueda </p> <p></p> <ul> <li>Enlace al archivo stl de la rueda. Recuerda que son necesarias dos unidades y dos juntas t\u00f3ricas, una para cada rueda, que actur\u00e1n de neum\u00e1ticos.</li> </ul> <p>El aspecto del encoder para la rueda es:</p> <p> <p> Encoder </p> <p></p> <ul> <li>Enlace al archivo stl del encoder.</li> </ul> <p>En la imagen vemos el encoder colocado en la rueda:</p> <p> <p> Encoder colocado </p> <p></p> <p>A continuaci\u00f3n se enlaza el archivo fuente.</p> <ul> <li>Archivo de dise\u00f1o en FreeCAD de la rueda y el encoder por si necesitas modificar algo.</li> </ul>"},{"location":"3DBot/montajeCorte/","title":"Gu\u00eda de montaje versi\u00f3n corte en madera","text":"<p>La presente gu\u00eda de montaje est\u00e1 basada en IMAGINA 3DBot + ESP32 STEAMakers (PUB) de Toni Hortal (para Robolot). </p> <p>La obra est\u00e1 publicada bajo licencia de Reconeixement-NoComercial-CompartirIgual 4.0 Internacional de Creative Commons.</p> <p>Las im\u00e1genes s\u00f3n originales de Kike Monta\u00f1\u00e9s</p> <p>El kit Imagina 3dBot se presenta as\u00ed:</p> <p> <p> Presentaci\u00f3n del kit </p> <p></p>"},{"location":"3DBot/montajeCorte/#material","title":"Material","text":"<p>Al abrir la caja encontrar\u00e1s todo el material necesario:</p> <p> <p> Material </p> <p></p> <p>El kit incluye:</p> <ul> <li>1 l\u00e1mina de madera con el chasis troquelado. Es sustituible por piezas impresas en 3D</li> <li>1 Placa de control ESP32 STEAMakers con cable USB</li> <li>1 Shield Imagina 3DBot V4 Innova Didactic</li> <li>2 Motores con placa + cables con dos ruedas</li> <li>3 Sensores de infrarrojos siguel\u00edneas</li> <li>3 Cables M-M de 20 cms. para conectar los sensores de l\u00ednea</li> <li>1 Power-Bank con cable de carga</li> <li>1 Sensor de ultrasonidos HC-SR04 de 4 pins</li> <li>1 bola de acero de 16mm de di\u00e1metro</li> <li>1 Mando de infrarrojos para control remoto</li> <li>1 Juego de torniller\u00eda compuesto por:<ul> <li>4 tornillos M3x10mm</li> <li>4 tornillos M3x15mm</li> <li>8 tuercas M3</li> </ul> </li> <li>Herramientas para el montaje:<ul> <li>1 mini llave de tubo M3</li> <li>1 destornillador de estrella</li> </ul> </li> </ul> <p>En la imagen vemos las herramientas.</p> <p> <p> Herramientas que acompa\u00f1an al kit </p> <p></p>"},{"location":"3DBot/montajeCorte/#montaje","title":"Montaje","text":"<p>Saca las piezas de la caja, quitales los envoltorios.</p> <p> <p> Unboxing 3DBot </p> <p></p> <p>El conjunto del chasis viene en una l\u00e1mina precortada como la siguiente:</p> <p> <p> L\u00e1mina DM precortada </p> <p></p> <p>Desencaja las piezas pero recuerda que las piezas son de un material similar a la madera (DM), que ajustan perfectamente, pero ten en cuenta su fragilidad si en fuerzas el encaje.</p> <p>Empieza con las piezas que forman la zona de la bola de acero.</p> <p>Este encaje es delicado y, por tanto, debes prestar atenci\u00f3n a su manipulaci\u00f3n.</p> <p> <p> Rueda loca </p> <p></p> <p>Encaja ambas piezas colocandolas sobre la mesa y haciendo presi\u00f3n de forma uniforme con ambos dedos y conseguir\u00e1s un conjunto robusto, como muestran las im\u00e1genes:</p> <p> <p> Rueda loca </p> <p></p> <p>Una vez creado el conjunto inserta la bola:</p> <p> <p> Rueda loca </p> <p></p> <p>Entrar\u00e1 de forma suave, quedando un grupo final que dar\u00e1 movilidad al robot por su parte trasera.</p> <p>Seguidamente monta los soportes de ambos motores:</p> <p> <p> Soporte de motores </p> <p></p> <p>Introduce los tornillos M3 de 25 mm por la parte posterior del motor y termina la fijaci\u00f3n con las tuercas M3 por su parte exterior, haciendo uso de las herramientas (destornillador y llave de tubo):</p> <p> <p> Soporte de motores </p> <p></p> <p>Con los dos soportes de motores fijados, monta el chasis por su parte inferior.</p> <p>Encaja cada uno de los motores en la l\u00e1mina que forma la parte de debajo del chasis.</p> <p> <p> Soporte de motores </p> <p></p> <p>Una vez encajados, inserta las piezas en forma de T para fijar el conjunto y darle robustez. Estas peque\u00f1as piezas tienen cierta dificultad a la hora de ser insertadas, pero es posible. Y dan as\u00ed mucha solidez a todo el grupo de piezas que forman el robot.</p> <p> <p> Soporte de motores </p> <p></p> <p>Ahora encaja la parte que har\u00e1 de tope en la powerbank por la parte delantera:</p> <p> <p> Tope powerbank </p> <p></p> <p>A continuaci\u00f3n la pieza de la parte trasera:</p> <p> <p> Tope powerbank </p> <p></p> <p>Coloca la powerbank en su \"interior\". Ten en cuenta que la zona de carga de la powerbank va hacia la parte trasera del robot. Y que las conexiones (puertos USB) deben estar centrados en la \u201cventana\u201d de esta pieza. \u00a1Comprueba que puedes conectar los dos extremos del cable USB a los dos puertos!</p> <p> <p> Tope powerbank </p> <p></p> <p>Dejamos a un lado el montaje actual y ahora sujetamos la placa ESP32 STEAMakers a la pieza superior del chasis:</p> <p> <p> Sujetar la placa ESP32 STEAMakers </p> <p></p> <p>S\u00f3lo ser\u00e1 necesario anclar la placa por 3 puntos con los tornillos cortos M3 y haciendo uso de las herramientas:</p> <p> <p> Sujetar la placa ESP32 STEAMakers </p> <p></p> <p>Deber\u00eda quedar as\u00ed:</p> <p> <p> Sujetar la placa ESP32 STEAMakers </p> <p></p> <p>Contin\u00faa ahora encajando la parte superior del chasis sobre el montaje inferior. El robot comienza a tomar forma.</p> <p> <p> Partes superior e inferior colocadas </p> <p></p> <p>Ahora colocamos todas las piezas en T para dar rigidez a todo el conjunto:</p> <p> <p> Partes superior e inferior colocadas </p> <p></p> <p>Encaja ahora la pieza de la bola loca y su pasador en T:</p> <p> <p> Colocaci\u00f3n de la bola loca </p> <p></p> <p>El aspecto actual del robot es:</p> <p> <p> Robot con la bola loca colocada </p> <p></p> <p>Ahora colocamos la placa Imagina 3DBot sobre la ESP32 STEAMakers:</p> <p> <p> Colocaci\u00f3n de la placa Imagina 3DBot </p> <p></p> <p>Ahora montamos los sensores seguidores de l\u00ednea TCRT5000:</p> <p> <p> Colocaci\u00f3n de sensor TCRT5000 </p> <p></p> <p>Fija los dos sensores frontales con los tornillos M3x8mm haciendo uso de las herramientas:</p> <p> <p> Fijaci\u00f3n de sensores TCRT5000 </p> <p></p> <p>Fija el tercer sensor TCRT5000 en el lateral derecho del robot y coloca las ruedas en su lugar:</p> <p> <p> Fijaci\u00f3n tercer sensor TCRT5000 y ruedas </p> <p></p> <p>Ya tiene mejor aspecto.</p> <p>El sensor de ultrasonidos se conecta directamente a la placa Imagina 3DBot, sin cables, al conector de 4 pines que hay detr\u00e1s del pulsador D2.</p> <p> <p> Colocaci\u00f3n del sensor de ultrasonidos HC-SR04 </p> <p></p>"},{"location":"3DBot/montajeCorte/#conexionado-del-robot-3dbot","title":"Conexionado del robot 3DBot","text":"<p>En este punto ya puedes iniciar el cableado de los componentes electr\u00f3nicos.</p> <p>El motor izquierdo se conecta al drive A y el motor derecho al drive B. El sensor izquierdo a SL, el derecho a SR y el sensor lateral a A1.</p> <p> <p> Conexionado del robot 3DBot </p> <p></p> <p>Para evitar que los cables de los 3 sensores seguidores de l\u00ednea queden por delante del sensor de ultrasonidos y del sensor de infrarrojo, pasalos por entre las dos placas hasta los conectores correspondientes:</p> <p>El aspecto final del robot es el siguiente:</p> <p> <p> Robot 3DBot finalizado </p> <p></p> <p>Nota: observa que te sobrar\u00e1 una pieza de encaje en T (es para una posible p\u00e9rdida de alguna de ellas).</p> <p>MISI\u00d3N CUMPLIDA!!!!</p> <p>Ya estamos listos para continuar con las actividades con el robot 3DBot.</p>"},{"location":"3DBot/montajeImpresa/","title":"Gu\u00eda de montaje versi\u00f3n pieza impresa 3D","text":"<p>La presente gu\u00eda de montaje es la que aparece en el manual que acompa\u00f1a al kit y que est\u00e1 disponible en la Tienda - Innovad Ddactic</p> <p>En esta secci\u00f3n vamos a explicar el montaje a partir de la nueva versi\u00f3n del chasis 3DBot formado por una sola pieza.</p>"},{"location":"3DBot/montajeImpresa/#material","title":"Material","text":"<p>El kit Imagina 3dBot incluye:</p> <ul> <li>1 Chasis impreso en 3D compacto: 2 ruedas + 2 juntas t\u00f3ricas y 1 bola de pl\u00e1stico</li> <li>1 Placa de control ESP32 STEAMakers con cable USB</li> <li>1 Shield Imagina 3DBot V4 Innova Didactic</li> <li>2 Motores con placa + cables (Ref. ID_MOTOR_PLACA)</li> <li>3 Sensores infrarrojo siguel\u00edneas (Ref. RBL030120)</li> <li>3 Cables M-M de 20 cms. para conectar los sensores de l\u00ednea (Ref. RBLSENSOR-PP)</li> <li>1 Power-Bank 5V/2200 mAh (Ref. VL2200PB001GR)</li> <li>1 Sensor de ultrasonidos de 4 pins (Ref. HC-SR04)</li> <li>1 Mando para control remoto (Ref. KS9002)</li> <li>1 Juego de torniller\u00eda compuesto por:<ul> <li>4 DIN7981 2,9*25mm</li> <li>7 DIN7981 2,9*6,5mm</li> <li>2 DIN7985 M3*12mm</li> <li>2 DIN934 M3</li> </ul> </li> </ul> <p>En la imagen vemos el contenido del kit.</p> <p> <p> Material </p> <p></p> <p>Las piezas impresas en 3D son las siguientes:</p> <p> <p> Chasis 3DBot Disponible en: Tienda - Innovad Ddactic</p> <p></p> <p>Ser\u00e1n necesarias las ruedas tambi\u00e9n impresas en 3D:</p> <p> <p> Rueda 3DBot Disponible en: Tienda - Innovad Ddactic</p> <p></p> <p>Las ruedas necesitan de neum\u00e1ticos, que se consiguen a partir de una junta t\u00f3rica:</p> <p> <p> T\u00f3rica neum\u00e1tico Disponible en: Tienda - Innovad Ddactic</p> <p></p> <p>Para funcionar con dos ruedas apoyamos el chasis en una rueda loca:</p> <p> <p> Bola soporte chasis Disponible en: Tienda - Innovad Ddactic</p> <p></p>"},{"location":"3DBot/montajeImpresa/#montaje-esp32-steamakers-e-imagina-3dbot","title":"Montaje ESP32 STEAMakers e Imagina 3DBot","text":"<p>Montaremos la placa ESP32 STEAMakers en la caja de soporte de la placa con 3 tornillos de estrella de 2,9\u00d76,5mm. Encima de esta, instalaremos el Shield Imagina 3DBot y ya podemos conectar la placa ESP32 STEAMakers al ordenador con el cable USB.</p> <p> <p> Montaje ESP32 STEAMakers e Imagina 3DBot </p> <p></p>"},{"location":"3DBot/montajeImpresa/#montaje-y-conexionado-del-robot-3dbot","title":"Montaje y conexionado del robot 3DBot","text":"<p>Colocamos o verificamos que el chasis ya lleve puesta la rueda \u201cloca\u201d trasera.</p> <p> <p> Rueda loca </p> <p></p> <p>Preparamos el motor izquierdo (motor A), que es el motor que lleva incorporado el sensor de l\u00ednea fotoel\u00e9ctrico que hace de \u201cencoder\u201d.</p> <p>Hemos de poner el soporte para el sensor de l\u00ednea tal y como se ve en la fotograf\u00eda con un tornillo de 2,9\u00d76,5mm.</p> <p> <p> Motor izquierdo </p> <p></p> <p>Sujetamos al chasis los motores del robot apret\u00e1ndolos con dos tornillos de 2,9x25mm. </p> <p>\u00a1Importante! No hay que apretar en exceso los tornillos para no aplastar la caja reductora y los engranajes de los motores.</p> <p>Hemos de tener en cuenta que el motor A, que lleva el encoder, es el que se coloca a la izquierda.</p> <p> <p> Motores </p> <p></p> <p>Insertamos la bater\u00eda Power Bank, en la parte inferior del chasis con el connector USB hacia la parte trasera.</p> <p> <p> Power Bank </p> <p></p> <p>Conectamos el motor izquierdo a motor A y el motor derecho a motor B en la placa.</p> <p> <p> Conexionado de motores </p> <p></p> <p>Colocamos los sensores de l\u00ednea fotoel\u00e9ctricos, sujet\u00e1ndolos con tornillos de M3x12mm y tuercas de M3.</p> <p> <p> Sensores de l\u00ednea </p> <p></p> <p>Una vez los tenemos montados, conectamos el sensor fotoel\u00e9ctrico izquierdo a la entrada D5 o SL, y el sensor fotoel\u00e9ctrico derecho a la entrada D6 o SR, con sus respectivos cables.</p> <p>Tambi\u00e9n conectamos a la entrada D15 el sensor de l\u00ednea fotoel\u00e9ctrico de la rueda izquierda (encoder).</p> <p> <p> Conexionado sensores de l\u00ednea y encoder </p> <p></p> <p>Colocamos las juntas t\u00f3ricas en las ruedas y a su vez colocamos estas en los ejes de los motores.</p> <p> <p> Ruedas </p> <p></p> <p>Conectamos el sensor de ultrasonidos a la placa Imagina 3DBot en su correspondiente z\u00f3calo, en la parte delantera de la placa.</p> <p> <p> Ultrasonidos </p> <p></p> <p>El aspecto final del robot es:</p> <p> <p> Robot 3DBot </p> <p></p> <p>Ya estamos listos para continuar con las actividades con el robot 3DBot.</p>"},{"location":"3DBot/motorDC/","title":"El motor de corriente continua","text":"<p>Se suelen denominar como motores DC (del ingl\u00e9s Direct Current) o motores CC y son m\u00e1quinas que convierten la energ\u00eda el\u00e9ctrica en mec\u00e1nica en base a un campo magn\u00e9tico que provoca un movimiento de rotaci\u00f3n en el eje del motor.</p> <p>Un motor de corriente continua tiene dos partes bien diferenciadas:</p> <ul> <li>Estator. Es la parte fija del motor y son bobinas de hilo de cobre devanadas en n\u00facleos magn\u00e9ticos.</li> <li>Rotor. Es la parte movil del motor y suele tener forma de cilindro, tambi\u00e9n es un devanado con n\u00facleo que se alimenta con corriente continua a trav\u00e9s de las delgas.</li> </ul> <p>En la animaci\u00f3n de la figura siguiente vemos el principio de funcionamiento de un motor DC explicado a partir del caso de una espira conductora dentro de un campo magn\u00e9tico a la que se aplica una tensi\u00f3n entre sus extremos que hace circular por la misma una corriente el\u00e9ctrica.</p> <p> <p> Base de funcionamiento de un motor DC Fuente: Wikipedia</p> <p></p> <p>En esta imagen existe un campo magn\u00e9tico permanente producido por imanes en el estator. El flujo de corriente en el devanado del rotor produce una fuerza de Lorentz sobre el devanado, representada por las flechas verdes. Debido a que en este caso el motor tiene dos polos, la conmutaci\u00f3n se hace por medio de un anillo partido a la mitad, donde el flujo de corriente se invierte cada media vuelta (180 grados).</p> <p>En la figura siguiente vemos el esquema del funcionamiento de un motor de c.c. elemental de dos polos con una sola bobina y dos delgas en el rotor. Se muestra el motor en tres posiciones del rotor desfasadas 90\u00b0 entre s\u00ed.</p> <ul> <li>1, 2: Escobillas</li> <li>A, B: Delgas</li> <li>a, b: Lados de la bobina conectados respectivamente a las delgas A y B</li> </ul> <p> <p> Esquema de funcionamiento de un motor DC Fuente: Wikipedia</p> <p></p> <p>En la figura siguiente vemos el aspecto de dos motores t\u00edpicos para aplicaciones en las que se utilizan placas tipo Arduino.</p> <p> <p></p> <p>Aspecto de motores DC</p> <p></p>"},{"location":"3DBot/motorDC/#control-de-motores-dc","title":"Control de motores DC","text":"<p>Las salidas de las placas Arduino son capaces de proporcionar unos 50mA como m\u00e1ximo y no van a servir para el control de un motor DC que tendr\u00e1 un consumo de hasta 1A. La soluci\u00f3n est\u00e1 en realizar el control del motor a trav\u00e9s de un controlador o driver que es gobernado por la placa de control, se alimenta de forma externa y excita al motor. En la figura siguiente vemos esquematizado el concepto.</p> <p> <p> Concepto de control por driver</p> <p></p> <p>El sistema mas sencillo de control todo o nada de un motor DC lo conseguimos a trav\u00e9s de un transistor, tal y como vemos en la figura siguiente.</p> <p> <p> Control de motor DC con transistor</p> <p></p> <p>Pero es evidente que necesitamos un control mas completo del motor en el que se permita:</p> <ul> <li>Invertir el sentido de giro.</li> <li>Controlar la velocidad de giro.</li> </ul> <p>Existen muchos drivers diferentes que consiguen estos objetivos y casi todos basan su funcionamiento en el denominado puente en H estando su principal diferencia en el circuito integrado que utilizan y la corriente m\u00e1xima que es capaz de entregar.</p>"},{"location":"3DBot/motorDC/#puente-en-h-con-interruptores","title":"Puente en H con interruptores","text":"<p>Vamos a explicar el funcionamiento de un puente en H utilizando para ello un circuito creado con interruptores y el principio b\u00e1sico de que en los motores DC el sentido de giro depende de la polaridad de alimentaci\u00f3n. En la figura siguiente tratamos de expresar el hecho de que cambiando la polaridad de la bater\u00eda cambia el sentido de giro del motor.</p> <p> <p> Cambio de polaridad para cambiar sentido de giro</p> <p></p> <p>El puente en H m\u00e1s b\u00e1sico que podemos construir lo vemos en la figura siguiente, donde observamos que su nombre se debe a la similitud que tiene el esquema con la letra H.</p> <p> <p> Puente en H con interruptores</p> <p></p> <p>Veamos las posibles combinaciones que podemos realizar accionando dos interruptores:</p> <ol> <li>Cerramos SW1 y SW4. Las conexiones son: positivo motor a positivo bater\u00eda y negativo motor a negativo bater\u00eda. Sentido de giro: horario.</li> <li>Cerramos SW2 y SW3. Las conexiones son: positivo motor a negativo bater\u00eda y negativo motor a positivo bater\u00eda. Sentido de giro: antihorario.</li> <li>Cerramos SW1 y SW2 o SW3 y SW4. Se provoca un CORTOCIRCUITO en la alimentaci\u00f3n.</li> <li>Cerramos SW1 y SW3 o SW2 y SW4. Se cortocircuitan los terminales del motor lo que mantiene al motor frenado.</li> </ol> <p>Es evidente que un puente en H as\u00ed construido no nos va a servir para mucho mas que para explicar el funcionamiento del sistema, pero si reemplazamos los interruptores por un sistema de control que abra y cierre el circuito de cada interruptor es evidente que si tendremos un sistema de control del sentido de giro muy vers\u00e1til.</p>"},{"location":"3DBot/motorDC/#puente-en-h-con-transistores","title":"Puente en H con transistores","text":"<p>Si a un transistor lo hacemos trabajar en conmutaci\u00f3n su comportamiento es muy similar al de un interruptor asimilando el estado de corte del transistor al de interruptor abierto y el de saturaci\u00f3n al de cerrado. Es entonces posible sustituir los interruptores por transistores y tendremos una configuraci\u00f3n de puente en H como la de la figura siguiente. Este es un circuito simplificado donde adem\u00e1s se ha a\u00f1adido una l\u00f3gica de control b\u00e1sica que permite explicar el funcionamiento.</p> <p> <p> Puente en H con transistores</p> <p></p> <p>Los transistores pueden ser NPN (el caso expuesto), PNP o pares complementarios y pueden ser de uni\u00f3n o MOSFET de potencia variando as\u00ed la m\u00e1xima corriente que son capaces de entregar y por lo tanto el tama\u00f1o del motor.</p> <p>El funcionamiento del circuito es el siguiente:</p> <ul> <li>Pin enable. Si es 0 todas las puertas AND tendr\u00e1n un cero en la salida un 0 con lo que los transistores est\u00e1n en corte y al motor no le llega alimentaci\u00f3n. El pin enable a 1 habilita la otra entrada de las 4 puertas AND para que en la misma aparezca la otra entrada.</li> <li>Enable = 1, IN1 = 1 e IN2 = 0. Los transistores Q1 y Q4 se saturan por lo que el motor queda polarizado directamente tal y como se muestra en la imagen y por lo tanto girar\u00e1 en sentido horario.</li> <li>Enable = 1, IN1 = 0 e IN2 = 1. Los transistores Q2 y Q3 se saturan por lo que el motor queda polarizado inversamente y por lo tanto girar\u00e1 en sentido antihorario.</li> <li>Enable = 1, IN1 = 1 e IN2 = 1. Se saturan los transistores Q1 y Q3 y al motor solamente le llega el positivo de alimentaci\u00f3n por lo que permanecer\u00e1 parado.</li> <li>Enable = 1, IN1 = 0 e IN2 = 0. Se saturan los transistores Q2 y Q4 y el motor permanecer\u00e1 frenado.</li> </ul>"},{"location":"3DBot/motorDC/#l293d","title":"L293D","text":"<p>Se trata de un circuito integrado que con sus 16 patillas nos da la posibilidad de controlar dos motores DC y su sentido de giro gracias a los cuatro medios puentes en H que lleva en su interior. El datasheet del L293D nos ofrece toda la informaci\u00f3n referente al circuito, cuyo aspecto real vemos en la imagen siguiente.</p> <p> <p> Aspecto L293D</p> <p></p> <p>En la figura siguiente vemos la distribuci\u00f3n de patillas y en la tabla la funci\u00f3n de cada una de ellas.</p> <p> <p> Pines L293D</p> Pin Nombre Tipo Descripci\u00f3n 1 1,2EN Entrada Habilita driver canales 1 y 2. Activa a nivel alto 2,7,10,15 1A,2A,3A,4A Entrada Entradas de los drivers no invertidas 3,6,11,14 1Y,2Y,3Y,4Y Salida Salidas de los drivers 9 3,4EN Entrada Habilita driver canales 3 y 4. Activa a nivel alto 4,5,12,13 Masa Alimentaci\u00f3n Masa del dispositivo y pines para refrigeraci\u00f3n en la PCB 16 VCC1 Alimentaci\u00f3n 5V para alimentar la l\u00f3gica interna 8 VCC2 Alimentaci\u00f3n Alimentaci\u00f3n de potencia para los drivers de 4.5 a 36V <p></p> <p>En la figura siguiente vemos el circuito que debemos montar para el control bidireccional de un motor y su tabla de funcionamiento.</p> <p> <p> Control bidireccional de motor DC con  L293D</p> <p></p> EN 1A 2A Funci\u00f3n 1 0 1 Giro a derechas 1 1 0 Giro a izquierdas 1 0 0 Parada r\u00e1pida del motor 0 X X Parada controlada del motor <p></p> <p>Si conectamos los pines enable a pines PWM podemos controlar la velocidad de giro de los motores.</p>"},{"location":"3DBot/motorDC/#l298","title":"L298","text":"<p>Es tambi\u00e9n un driver puente en H capaz de manejar motores DC de hasta 2 amperios. El chip L298N internamente posee dos puentes en H completos que permiten controlar 2 motores DC o un motor paso a paso bipolar o unipolar. El datasheet L298 nos suministra toda la informaci\u00f3n del circuito integrado discreto, pero la forma usual que facilita su conexionado y manejo es una placa de control puente en H basada en el L298 que tiene el aspecto que vemos en la imagen siguiente.</p> <p> <p> Aspecto driver basado en L298N</p> <p></p> <p>El m\u00f3dulo permite controlar el sentido y velocidad de giro de motores mediante se\u00f1ales TTL. El control del sentido de giro se realiza mediante dos pines para cada motor y la velocidad de giro se puede regular haciendo uso de modulaci\u00f3n por ancho de pulso. El m\u00f3dulo lleva un regulador de voltaje LM7805 de 5V encargado de alimentar la parte l\u00f3gica del L298N, el uso de este regulador se hace a trav\u00e9s de un Jumper y se puede usar para alimentar la etapa de control.</p> <p>Sus principales especificaciones t\u00e9cnicas son:</p> <ul> <li>2 Canales que permiten conectar 2 motores DC</li> <li>Voltaje para l\u00f3gica: 5V</li> <li>Voltaje de potencia (alimentaci\u00f3n motor): 5V - 35V</li> <li>Consumo de corriente (l\u00f3gica): 0 a 36mA</li> <li>Corriente m\u00e1xima de salida: 2A (soporta picos de hasta 3A)</li> <li>Potencia m\u00e1xima: 25W</li> </ul> <p>En este tutorial de naylampmechatronics nos explican muy claramente como utilizar este driver.</p> <p> <p> Conexionado de los drivers</p> <p></p> <p>Existe otro driver L298, el L298P que es una shield o m\u00f3dulo tipo UNO permite tambi\u00e9n manejar dos motores DC a trav\u00e9s de una configuraci\u00f3n de puente en H. Esta placa incorpora adem\u00e1s interfaz bluetooth, zumbador, servo, motores paso a paso y tambi\u00e9n incorpora conexi\u00f3n a 6 pines anal\u00f3gicos (A0 - A5) y 6 pines digitales no utilizados (D2,D3,D5,D6,D7 y D9). En la figura siguiente vemos su aspecto.</p> <p> <p> Aspecto driver basado en L298P</p> <p></p> <p>Existe una versi\u00f3n de la shield en la que no se monta nada mas que el driver de motores dejando las zonas de la placa no ocupadas con perforaciones que permiten agregar componentes externos para completar nuestro propio experimento. En la figura siguiente vemos el aspecto de una de estas placas.</p> <p> <p> Aspecto driver basado en L298P con solo el driver</p> <p></p>"},{"location":"3DBot/motorDC/#bloques-de-programacion","title":"Bloques de programaci\u00f3n","text":"<p>A fecha de creaci\u00f3n de esta web los bloques disponibles para motores DC en el men\u00fa 'Motor' los vemos en la figura siguiente.</p> <p> <p> Bloques para control de motores DC</p> <p></p> <p>El bloque 'Motor DC' permite controlar el sentido de giro y la velocidad de un motor, los dos bloques que le siguen sirven para programar el funcionamiento de dos motores a partir de un puente en H tipo L293N y los dos \u00faltimos para un puente H basado en L298P. Pero al menos por ahora no es posible configurar dos bloques diferentes para puente en H que permitan el control de dos motores adicionales.</p> <p>Tambi\u00e9n podemos utilizar para la programaci\u00f3n de los motores los bloques del men\u00fa 'Entrada/salida' que vemos en la figura siguiente.</p> <p> <p> Bloques gen\u00e9ricos de E/S para control de motores DC</p> <p></p>"},{"location":"ESP32/Cenergia/","title":"Consumo de energia","text":"<p>La placa ESP32 STEAMakers dispone de un sistema para medir el consumo de energ\u00eda.</p> <p>En Arduinoblocks, el medidor de consumo de energ\u00eda se encuentra en la categor\u00eda Sensores \u2192 Integrados:</p> <p> <p> Sensores integrados en ESP32 STEAMakers </p> <p></p> <p>Permite medir tanto la intensidad (Amps) en amperios, como la tensi\u00f3n (Volts) en voltios, la potencia (Power) en vatios y la energ\u00eda (Energy) en vatios por hora:</p> <p> <p> Variables que se pueden medir </p> <p></p>"},{"location":"ESP32/Cenergia/#monitorizacion-del-consumo-de-energia","title":"Monitorizaci\u00f3n del consumo de energia","text":"<p>Para hacerlo vamos a montar el circuito de la figura siguiente utilizando una ESP32 STEAMakers, una placa protoboard. Conectamos dos pulsadores a los pines IO26 (D2) e IO27 (D6) y tres diodos LED a los pines IO25 (D3), IO17 (D4) e IO16 (D5).</p> <p> <p> Montaje para el ejemplo 3DB_Ej4 </p> <p></p> <p>El primer pulsador enciende los LEDs y el segundo los apaga.</p> <p>Si no tenemos conectado nada el valor de la intensidad deber\u00eda ser cero. Cuando se enciende los LEDs se producir\u00e1 una peque\u00f1a variaci\u00f3n en la intensidad y para verla mejor se ha expresado en miliamperios.</p> <p>El programa para saber el valor de las cuatro magnitudes es el siguiente:</p> <p> <p> Enlace a ejemplo 3DB_Ej4</p> <p></p> <p>Conecta la placa a un puerto USB del ordenador, pon en marcha Arduinoblocks Connector, espera a que identifique la placa y el puerto y pulsa en el bot\u00f3n Subir.</p> <p>Abre la Consola, selecciona la velocidad de comunicaci\u00f3n seg\u00fan la establecida en el programa y pulsa Conectar.</p> <p>En la Consola serie podemos ver los valores de las 4 magnitudes, algunas de las cuales variar\u00e1n en funci\u00f3n de si est\u00e1n encendidos o no los LEDs.</p> <p>En el video ENERGIA ESP32 PARTE I de Ardutaller tenemos una completa informaci\u00f3n del tema.</p>"},{"location":"ESP32/Sinternos/","title":"Sensores internos","text":"<p>La placa ESP32 STEAMakers, al estar basada en el ESP32-WROOM-32, dispone de 2 sensores integrados. Se trata de un sensor de efecto Hall y un sensor de temperatura.</p> <p>Los bloques para utilizarlos se encuentran en la categor\u00eda Sensores \u2192 Integrados:</p> <p> <p> Bloques sensores integrados</p> <p></p> <p>Con el sensor de efecto Hall podremos detectar variaciones de campo magn\u00e9tico en las proximidades de la placa.</p> <p>Con el sensor de temperatura podremos controlar la temperatura a la que se encuentra el procesador de la placa.</p> <p>A continuaci\u00f3n podemos ver un ejemplo de lectura de dichos sensores:</p> <p> <p> Enlace a ejemplo 3DB_Ej6</p> <p></p> <p>Conecta la placa a un puerto USB del ordinador, lanza Arduinoblocks Connector, espera a que se identifique la placa y reconozca el puerto y haz clic en el bot\u00f3n 'Subir'.</p> <p>Abre la consola serie y haz clic en conectar seleccionando previamente la velocidad de comunicaci\u00f3n seg\u00fan el valor establecido en el programa.</p> <p>En la consola serie podemos ver los valors de temperatura y si tenemos cerca un objeto met\u00e1lico. Si el objeto met\u00e1lico esta sobre la placa debe aumentar el valor de la variable de proximidad y si lo alejamos disminuye.</p>"},{"location":"ESP32/Stactil/","title":"Sensores t\u00e1ctiles capacitivos","text":"<p>En este aparatado se muestra c\u00f3mo utilizar los pines de sensores t\u00e1ctiles capacitivos del ESP32. Estos pinos pueden captar variaciones en cualquier cosa que tenga una carga el\u00e9ctrica. A menudo se utilizan para despertar el ESP32 del modo deep sleep (sue\u00f1o profundo).</p>"},{"location":"ESP32/Stactil/#sensores-tactiles-de-la-esp32","title":"Sensores t\u00e1ctiles de la ESP32","text":"<p>El ESP32 puede llegar a tener 10 pines con sensores t\u00e1ctiles capacitivos, dependiendo del modelo con el que trabajemos. Estos GPIO pueden captar variaciones en cualquier cosa que tenga una carga el\u00e9ctrica, como la piel humana. As\u00ed, pueden detectarse variaciones inducidas cuando tocamos los GPIO con un dedo.</p> <p>Estos pinos pueden ser f\u00e1cilmente integrados en almohadillas (pads) capacitivos, y sustituir botones mec\u00e1nicos por botones t\u00e1ctiles. Adicionalmente, estos pinos pueden ser utilizados tambi\u00e9n como fuente para despertar al ESP32 del modo deep sleep.</p> <p>Veamos en primer lugar el pinout de una ESP32 con 30 GPIOs donde podemos localizar los sensores tipo 'touch' en color rosa.</p> <p> <p> Sensores t\u00e1ctiles en ESP32 DEVKIT V1 - DOIT</p> <p></p> <p>Puedes comprobar que el sensor 0 corresponde al GPIO 4, el sensor 2 al GPIO 2, y as\u00ed sucesivamente.</p> <p>Nota: el sensor 1 es el GPIO 0. Sin embargo, no est\u00e1 disponible como pin en esta placa de desarrollo particular de ESP32 (versi\u00f3n con 30 GPIO). El GPIO 0 est\u00e1 disponible en la versi\u00f3n de 36 pines de esa placa.</p> <p>Veamos ahora los pines touch en la ESP32 STEAMakers:</p> <p> <p> Sensores t\u00e1ctiles en la placa ESP32 STEAMakers </p> <p></p> <p>Los pines se localizan en color verde claro y observa como en este caso disponemos de seis: TOUCH0, TOUCH1, TOUCH2, TOUCH4, TOUCH5, TOUCH6 y TOUCH7.</p>"},{"location":"ESP32/Stactil/#lectura-del-sensor-tactil","title":"Lectura del sensor t\u00e1ctil","text":"<p>La lectura del sensor t\u00e1ctil es directa en el IDE de Arduino mediante el uso de la funci\u00f3n <code>touchRead()</code>, que acepta como argumento el GPIO que quieres leer:</p> <pre><code>touchRead(GPIO);\n</code></pre> <p>Vamos a programar la placa utilizando el IDE de Arduino, por lo que hay que asegurarse de tener instaladas las placas ESP32 antes de proceder.</p> <p> <p> Placas ESP32 en el IDE</p> <p></p> <p>Una vez conectada la ESP32 a un puerto USB y seleccionada la placa podemos ver c\u00f3mo trabaja esta funci\u00f3n utilizando un ejemplo de la librer\u00eda. Para ellos debes ir a Archivo \u2192 Ejemplos \u2192 ESP32 \u2192 Touch y abre el programa TouchRead.</p> <p> <p> Archivo \u2192 Ejemplos \u2192 ESP32 \u2192 Touch</p> <p></p> <p>Se abre una ventana con el siguiente programa:</p> <p> <p> Archivo \u2192 Ejemplos \u2192 ESP32 \u2192 Touch \u2192 TouchRead</p> <p></p> <p>A continuaci\u00f3n vemos el programa con algunas peque\u00f1as modificaciones:</p> <pre><code>// Prueba de pin tactil en ESP32\n// Touch7 es T7 que esta en GPIO 14.\n\nvoid setup()\n{\n  Serial.begin(115200);\n  delay(1000); // dame tiempo para subir monitor de serie\n  Serial.println(\"Prueba de sensor tactil en ESP32\");\n}\n\nvoid loop()\n{\n  Serial.println(touchRead(T7));  // obtener valor usando T7\n  delay(1000);\n}\n</code></pre> <p>Tambi\u00e9n podemos realizar el programa en Arduinoblocks haciendo el programa siguiente:</p> <p> <p> Enlace a ejemplo 3DB_Ej5</p> <p></p> <p>En la imagen siguiente vemos una captura del Serial Plotter mostrando los cambios al tocar el pin con el dedo.</p> <p> <p> Ejemplo 3DB_Ej5. Ventana Serial plotter</p> <p></p>"},{"location":"ESP32/Stactil/#mas-informacion","title":"Mas informaci\u00f3n","text":"<p>En los siguientes enlaces podemos ampliar la informaci\u00f3n sobre los sensores t\u00e1ctiles en las placas ESP32.</p> <ul> <li> <p>ESP32 Sensores t\u00e1ctiles del canal Youtube LaBuhardillaDelLoco</p> </li> <li> <p>Tutorial ESP32 Capacitive Touch Sensor Pins with Arduino IDE de RANDOM NERD TUTORIALS</p> </li> <li> <p>ESP32 Capacitive Touch Sensor Pins with Arduino IDE del canal Youtube Rui Santos</p> </li> </ul>"},{"location":"ESP32/introESP32/","title":"Introducci\u00f3n a la ESP32 STEAMakers","text":"<p>Esta placa est\u00e1 basada en el ESP32-WROOM-32, un microcontrolador de 32 bits, y nos ofrece una gran cantidad de prestaciones como:</p> <ul> <li>conectividad WiFi y Bluetooth integradas en la propia placa</li> <li>un z\u00f3calo para tarjetas microSD para el almacenamiento de datos</li> <li>conexiones para todas las entradas y salidas disponibles</li> <li>puertos de expansi\u00f3n I2C para poder conectar diferentes dispositivos I2C directamente a la placa</li> </ul> <p> <p> Aspecto de la placa ESP32 STEAMakers </p> <p></p> <p>En la figura siguiente vemos los elementos que componen la placa ESP32 STEAMakers:</p> <p> <p> Elementos en la placa ESP32 STEAMakers </p> <p></p>"},{"location":"ESP32/introESP32/#especificaciones-tecnicas","title":"Especificaciones t\u00e9cnicas","text":"<p>Sus principales especificaciones t\u00e9cnicas son:</p> <ul> <li>Microcontrolador Tensilica Xtensa 32-bit LX6 a 160MHz.</li> <li>Conectividad WiFi 802.11 b/g/n/e/i.</li> <li>Conectividad Bluetooth 4.2 y modo BLE.</li> <li>Z\u00f3calo para tarjetas \u00b5SD.</li> <li>14 entradas y salidas digitales con alimentaci\u00f3n.</li> <li>Conector serie hembra con alimentaci\u00f3n.</li> <li>Conector I2C para conectar hasta 5 dispositivos a la vez sobre la misma placa.</li> <li>Conector hembra I2C para conexi\u00f3n de una pantalla OLED.</li> <li>Bot\u00f3n de Reset.</li> <li>Conector de 5V</li> <li>Conector de 3.3V</li> <li>Interruptor 3.3-5V para cambiar entre estas dos tensiones en algunos pines de alimentaci\u00f3n.</li> <li>Entradas y salidas anal\u00f3gicas.</li> <li>Sensor Hall y de temperatura integrado.</li> <li>2 convertidores Digital-Anal\u00f3gico (DAC) de 8 bits.</li> <li>16 convertidores Anal\u00f3gico-Digital (ADC) de 12 bits.</li> <li>16 canales PWM.</li> <li>2 UART.</li> <li>2 canales I2C.</li> <li>4 canales SPI.</li> <li>448Kb ROM.</li> <li>520 KB SRAM.</li> <li>8KB+8KB SRAM en RTC.</li> <li>1kbit eFUSE.</li> <li>512 bytes Memoria Flash (EEPROM).10 sensores t\u00e1ctiles.</li> <li>4 temporizadores internos de 64 bits.</li> </ul> <p>No est\u00e1n disponibles todas las caracter\u00edsticas del controlador ESP-WROOM-32, ya que algunos pines tienen funciones dobles y se utilizan en la placa de forma espec\u00edfica (como, por ejemplo, para controlar la tarjeta microSD). Pero la mayor\u00eda de funciones se pueden utilizar, adem\u00e1s de disponer la placa ESP32 STEAMakers de una mejor conexi\u00f3n de elementos debido a los pines para conectores tipo Dupont de entrada y salida, de I2C y de alimentaci\u00f3n. Adem\u00e1s, algunos pines de alimentaci\u00f3n pueden cambiar su valor (3,3V o 5V) mediante un interruptor en funci\u00f3n de nuestras necesidades.</p> <p>En la figura siguiente vemos un momento del video descriptivo de la placa ESP32 STEAMakers que se aloja en el canal Youtube de Arduinoblocks. En la imagen se compara el potencial de la placa ESP32 STEAMakers con otras placas tradicionales.</p> <p> <p> Comparativa de la placa ESP32 STEAMakers </p> <p></p> <p>En la tabla siguiente se realiza una comparativa entre ESP32 y otras placas muy utilizadas.</p> <p> Especificaciones ESP32 STM32F103C8T6 ESP8266 Nano CPU Xtensa LX6 ARM Cortex M3 Xtensa L106 ATmega328P N\u00facleos 2 1 1 1 Arquitectura (bits) 32 32 32 8 Frecuencia CPU (MHz) 160 72 80 16 Comunicaciones WiFi, Bluetooth No WiFi No RAM (KB) 512 20 160 2 Flash 4 MB 64/128 KB 4 MB 32 KB Pines E/S 36 37 17 14 SPI/I2C/I2S/UART 4/2/\u2154 2/2/0/3 2/\u00bd/2 1/1/0/1 ADC 6 de 12 bits 10 de 12 bits 1 de 10 bit 6 de 10 bit DAC 2 0 0 0 <p></p>"},{"location":"ESP32/introESP32/#consideraciones-sobre-esp32","title":"Consideraciones sobre ESP32","text":"<p>En este apartado vamos a realizar algunas consideraciones sobre los siguientes aspectos de las placas ESP32:</p> <ul> <li>Pines</li> <li>Entradas anal\u00f3gicas</li> <li>Entradas y salidas digitales</li> <li>Salidas PWM en ESP32</li> </ul>"},{"location":"ESP32/introESP32/#pines-en-esp32","title":"Pines en ESP32","text":"<p>En general los pines en ESP32 son de tipo GPIO (General Purpose Input/Output, Entrada/Salida de Prop\u00f3sito General). Algunos pines GPIO pueden tener un comportamiento no esperado durante el arranque del sistema o en el reinicio del mismo. Esto se debe a que durante el arranque de la placa ESP32 se deben realizar procesos internos que ponen en alto ciertos pines o incluso hacen que emitan se\u00f1ales, y esto puede provocar esos efectos no deseados.</p> <p>El pin GPIO1 del microcontrolador es el pin Tx del puerto UART de depuraci\u00f3n y cuando la placa arranca, se reinicia o cuando nosotros hacemos uso del puerto serie, este pin emite datos. Por este motivo es un pin que no conviene usar como entrada o salida.</p> <p>El GPIO3 tiene un problema similar al GPIO1 ya que se trata del pin Rx del micocontrolador.</p> <p>Los pines GPIO34, GPIO35, GPIO36 y GPIO39 solamente pueden utilizarse como entradas porque no disponen de resistencia pull-up.</p>"},{"location":"ESP32/introESP32/#entradas-analogicas","title":"Entradas anal\u00f3gicas","text":"<p>Las se\u00f1ales anal\u00f3gicas son las que pueden tomar diferentes valores de tensi\u00f3n en un determinado periodo de tiempo, siendo su forma mas caracter\u00edstica la senoidal. Cuando hablamos de entradas anal\u00f3gicas estamos hablando de pines del microcontrolador que pueden leer esas se\u00f1ales. En el caso de ESP32 todo son pines GPIO y por lo tanto se requiere de un conversor anal\u00f3gico a digital que sea capaz de transformar esas se\u00f1ales anal\u00f3gicas en digitales. El chip ESP32 que monta la placa ESP32 STEAMakers dispone de 2 convertidores Digital-Anal\u00f3gico (DAC) de 8 bits y 16 convertidores Anal\u00f3gico-Digital (ADC) de 12 bits. Estos conversores se asocian a los pines IO1 hasta IO20.</p> <p>La resoluci\u00f3n de los conversores ADC es de 12 bits (2^12 = 4096) por lo que la transformaci\u00f3n de los valores digitales va a ser de mucha precisi\u00f3n. Pero cuidado con el uso de estas entradas, porque en realidad su comportamiento es que est\u00e1n leyendo valores digitales y no valores anal\u00f3gicos por lo que cambios de valores anal\u00f3gicos muy peque\u00f1os pueden no ser detectados.</p> <p>Los canales ADC se dividen en dos puertos denominados ADC1 y ADC2. Las entradas anal\u00f3gicas del puerto ADC2 solamente las podemos usar como tales si el controlador WiFi no ha sido iniciado, ya que este puerto es el que utiliza el controlador del WiFi que integra la placa.</p>"},{"location":"ESP32/introESP32/#entradas-y-salidas-digitales","title":"Entradas y salidas digitales","text":"<p>Una se\u00f1al digital solamente puede tomar dos valores o estados l\u00f3gicos, alto y bajo, High y Low, 0 y 1 siendo su representaci\u00f3n caracter\u00edstica una onda cuadrada. El estado bajo se asocia a cero voltios y el estado alto a 3.3V (5V en el caso de placa tipo UNO).</p> <p>Las entradas permiten recibir se\u00f1ales con los valores digitales descritos, como por ejemplo leer el estado de un pulsador.</p> <p>Debemos saber que ESP32 lleva unas resistencias de pull-up (1) o pull-down (0) que nos permiten establecer el estado que tiene la entrada cuando est\u00e1 en reposo. Estas resistencias est\u00e1n disponibles en todos los pines excepto el 34 y 39. Estas resistencias internas se pueden activar por c\u00f3digo.</p> <p>Las salidas digitales nos van a servir para realizar acciones sobre los elementos conectadas en ellas, como por ejemplo encender un LED o activar un rel\u00e9.</p> <p>En principio todos los pines que se pueden utilizar como salida en ESP32 pueden usarse con PWM excepto los pines que no disponen de resistencia de pull-up interna.</p>"},{"location":"ESP32/introESP32/#compatibilidad-y-descripcion-de-pines-esp32-steamakers","title":"Compatibilidad y descripci\u00f3n de pines ESP32 STEAMakers","text":"<p>Importante: Todos los pines IOxx son entradas y salidas digitales, algunas con m\u00e1s funciones. Utilizando la comunicaci\u00f3n WiFi no funciona el ADC2.</p> <p>En la tabla siguiente tenemos relacionados todos los pines entre los tipos de placas UNO y ESP32 STEAMakers.</p> <p> UNO ESP32 Pin Pin Funci\u00f3n Ampliaci\u00f3n D0 IO03 Rx UART 0 RX D1 IO01 Tx UART 0 TX D2 IO26 ADC2 CH9 DAC2 D3 IO25 ADC2 CH8 DAC1 D4 IO17 UART 2 TX D5 IO16 UART 2 RX D6 IO27 ADC2 CH7 TOUCH7 / HSPI CS D7 IO14 ADC2 CH6 TOUCH6 / HSPI SCK D8 IO12 ADC2 CH5 TOUCH5 / HSPI MISO D9 IO13 ADC2 CH4 TOUCH4 /  HSPI MOSI D10 IO05 VSPI CSO D11 IO23 VSPI MOSI D12 IO19 VSPI MISO D13 IO18 VSPI CLK GND GND 5V +5V SDA IO21 I2C SDA / VSPI HD SCL IO22 I2C SCL / VSPI WP A0 IO02 ADC2 CH2 TOUCH 2 / HSPI WP / E/S de RTC 12 procesador ultra baja potencia A1 IO04 ADC2 CH0 TOUCH 0 / HSPI CD / E/S de RTC 10 procesador ultra baja potencia A2 IO35 ADC1 CH7 E/S de RTC 5 procesador ultra baja potencia A3 IO34 ADC1 CH6 E/S de RTC 4 procesador ultra baja potencia A4 IO21 SDA A5 IO22 SCL VIN VIN GND GND GND GND 5V +5V 3.3V +3.3V RST Reset 5V 5V IO00 ADC2 CH1 TOUCH 1 / E/S de RTC 11 procesador ultra baja potencia - IO32 D0 - uSD - IO15 CLK - uSD - IO33 CMD - uSD - IO35 IOUT Medidor de corriente - IO37 VOUT Medidor de tensi\u00f3n <p></p> <p>En la figura siguiente podemos ver y descargar un gr\u00e1fico con el pinout de la ESP32 STEAMakers en formato original svg.</p> <p> <p> Comparativa de la placa ESP32 STEAMakers </p> <p></p>"},{"location":"ESP32/introESP32/#verificacion-de-la-alimentacion-de-la-steamakers","title":"Verificaci\u00f3n de la alimentaci\u00f3n de la STEAMakers","text":"<p>La ESP32 STEAMakers, como cualquier otra placa basada en ESP32, debe tener unos valores de alimentaci\u00f3n m\u00ednimos. Gracias a que la STEAMakers lleva incorporado un medidor de tensi\u00f3n e intensidad, podemos saber la tensi\u00f3n de alimentaci\u00f3n en todo momento.</p> <p>Si la tensi\u00f3n de alimentaci\u00f3n cae por debajo de 4,8 V (aproximadamente), la placa no funcionar\u00e1 correctamente, sobre todo en la comunicaci\u00f3n WiFi.</p> <p>Es recomendable realizar una verificaci\u00f3n de la tensi\u00f3n que est\u00e1 entregando el puerto USB del ordenador. Si la tensi\u00f3n no est\u00e1 cerca de 5 V deberemos cambiar el cable USB, alimentar el puerto USB de forma externa o alimentar la placa con una fuente de alimentaci\u00f3n.</p> <p>Podemos realizar un peque\u00f1o programa para verificar la alimentaci\u00f3n de la placa como el que vemos en la imagen siguiente:</p> <p> <p> Enlace a ejemplo 3DB_Ej3</p> <p></p> <p>Deber\u00eda ser un buen h\u00e1bito colocar estos bloques al inicio de cualquier programa para asegurarnos de una buena alimentaci\u00f3n, sobre todo si trabajamos directamente con la placa conectada al puerto USB del ordenador y empezamos a conectar elementos externos en la placa (pantallas, LED, servos, etc.).</p> <p>Tambi\u00e9n hay que tener en cuenta que, cuando utilicemos la comunicaci\u00f3n mediante WiFi, deja de funcionar el ADC2, por lo que no podremos leer los valores de sensores conectados a los pines A0 y A1. En este caso, la alternativa es conectarlos a los pinos A2 y/o A3.</p>"},{"location":"ESP32/microSD/","title":"Tarjeta microSD","text":"<p>La placa ESP32 STEAMakers dispone de un z\u00f3calo para poder insertar tarjetas microSD.</p> <p>Para que funcione correctamente, la tarjeta debe estar formateada en formato FAT32, permitiendose tama\u00f1os de hasta 2 TB y archivos de un tama\u00f1o m\u00e1ximo de 2 GB.</p> <p>La tarjeta da gran flexibilidad a la placa, ya que permite poder escribir y leer datos. Una de las funcionalidades m\u00e1s \u00fatiles es poder almacenar los datos de los sensores a modo de Datalogger. Tambi\u00e9n nos permitir\u00e1 leer datos de la tarjeta (por ejemplo, configuraciones de conexiones WiFi) para poder utilizarlos directamente en un programa.</p> <p>El z\u00f3calo para introducir la tarjeta microSD se encuentra en la parte posterior de la placa, como podemos ver en la siguiente imagen:</p> <p> <p> Lector de microSD</p> <p></p> <p>Nota importante: en la pr\u00e1ctica el tipo de tarjeta de memoria SD que podemos conectar es de un m\u00e1ximo de 32 GB y formateada en FAT32. Si son de mayor capacidad pueden no funcionar.</p> <p>Existen una serie de bloques espec\u00edficos en Arduinoblocks para controlar la funcionalidad de la tarjeta microSD:</p> <p> <p> Bloques para microSD</p> <p></p>"},{"location":"ESP32/microSD/#almacenar-datos-datalogger","title":"Almacenar datos: Datalogger","text":"<p>Vamos a realizar un programa que nos permita almacenar los valores de temperatura de la CPU en un archivo.</p> <p>Primero inicializaremos la tarjeta microSD y borramos el archivo que pueda haber anteriormente.</p> <p>A continuaci\u00f3n leeremos la temperatura la almacenaremos en el archivo de texto datos_temp_CPU.txt.</p> <p>Para separar los datos a\u00f1adiremos el s\u00edmbolo \u201c;\u201d para poder extraer despu\u00e9s los datos de forma m\u00e1s sencilla.</p> <p>Tomaremos las muestras en intervalos de 10 segundos.</p> <p>El programa que realizaremos es el siguiente:</p> <p> <p> Enlace a ejemplo 3DB_Ej7</p> <p></p> <p>Una vez colocamos la tarjeta en nuestro ordenador y la abrimos observaremos que se ha creado el archivo con el nombre que le hemos asignado.</p> <p>Y si abrimos el archivo veremos la secuencia de muestras que hemos tomado y el formato de n\u00fameros obtenido.</p>"},{"location":"ESP32/microSD/#leer-datos-almacenados","title":"Leer datos almacenados","text":"<p>Ahora vamos a leer los datos que hemos almacenado en el ejemplo anterior. Vamos a realizar un programa que nos permita volcar todos los datos por el puerto serie.</p> <p>El programa resultante es el siguiente:</p> <p> <p> Enlace a ejemplo 3DB_Ej8</p> <p></p>"},{"location":"ESP32/microSD/#escribir-y-leer-datos","title":"Escribir y leer datos","text":"<p>A continuaci\u00f3n vamos a realizar un programa que re\u00fana las dos funcionalidades vistas anteriormente. Utilizaremos un pulsador para iniciar la grabaci\u00f3n de los datos y otro pulsador para detener la grabaci\u00f3n. En el momento en que se detenga la grabaci\u00f3n de datos, los mostrar\u00e1 por la Consola serie. Mientras est\u00e9 almacenando datos se encender\u00e1 el LED rojo y cuando los muestre por la Consola serie encender\u00e1 el LED verde.</p> <p>Cada vez que apretemos el pulsador de almacenar datos se ir\u00e1n a\u00f1adiendo a las muestras que ya tenemos registradas.</p> <p> <p> Enlace a ejemplo 3DB_Ej9</p> <p></p> <p>La informaci\u00f3n que veremos por la Consola serie (cada vez que la abrimos, se reinicia el programa y empieza a tomar muestras desde cero): cada vez que almacena una muestra cuando pulsamos el pulsador de almacenar se a\u00f1ade una nueva muestra al archivo de datos (almacena datos).</p> <p>Al pulsar el bot\u00f3n de mostrar aparecen las muestras grabadas (mostra datos).</p>"},{"location":"IDE/caracteristicasIDE2_0/","title":"Caracter\u00edsticas principales del IDE 2.0","text":""},{"location":"IDE/caracteristicasIDE2_0/#ajustar-preferencias","title":"Ajustar preferencias","text":"<p>En la animaci\u00f3n de la figura siguiente vemos como acceder a la configuraci\u00f3n de las mismas y tambi\u00e9n como se realiza alg\u00fan ajuste adicional.</p> <p> <p> Preferencias IDE 2.0</p> <p></p>"},{"location":"IDE/caracteristicasIDE2_0/#la-carpeta-de-programas","title":"La carpeta de programas","text":"<p>Los programas o sketches de Arduino se guardan como .ino y deben almacenarse en una carpeta con el mismo nombre. Por ejemplo, un programa de nombre 'mi_programa.ino' debe almacenarse en una carpeta llamada 'mi_programa'. Generalmente se guardan en una carpeta de nombre 'Arduino' en la carpeta personal.</p> <p>En la animaci\u00f3n siguiente vemos como abrir y cerrar esta carpeta desde el bot\u00f3n de la barra lateral y como nos muestra el contenido</p> <p> <p> Carpeta de programas</p> <p></p>"},{"location":"IDE/caracteristicasIDE2_0/#administrador-de-placas","title":"Administrador de placas","text":"<p>Con el Administrador de placas se pueden buscar e instalar paquetes o \"n\u00facleos\" para nuestras placas. Compilar y cargar un programa en una placa siempre requiere un paquete de la placa. Hay muchos paquetes de placa Arduino disponibles, como avr, samd, megaav y muchos m\u00e1s.</p> <p>Podemos decir que un \"n\u00facleo\" est\u00e1 escrito y dise\u00f1ado para microcontroladores espec\u00edficos y sabemos que las diferentes placas tienen micros de diferentes tipos. Por ejemplo, un Arduino UNO tiene un ATmega328P, que usa el n\u00facleo AVR, mientras que un Arduino Nano 33 IoT tiene un microcontrolador SAMD21, donde necesitamos usar el n\u00facleo SAMD. En definitiva, para poder usar una placa concreta debemos instalar su n\u00facleo espec\u00edfico.</p> <p>Al hacer clic en el bot\u00f3n de la barra lateral se nos abren todas las opciones disponibles y ne indica si est\u00e1n o no instalados y adem\u00e1s dispone de un buscador que permite localizar el n\u00facleo que necesitamos. Hay que tener presente que la instalaci\u00f3n de algunos de ellos puede tardar varios minutos.</p> <p>En la animaci\u00f3n vemos el funcionamiento de este bot\u00f3n.</p> <p> <p> Administrador de placas</p> <p></p>"},{"location":"IDE/caracteristicasIDE2_0/#gestor-de-librerias","title":"Gestor de librer\u00edas","text":"<p>Este bot\u00f3n nos permite buscar e instalar librer\u00edas, que son extensiones de la API de Arduino que facilitan el control de un servo, leer un sensor espec\u00edfico o utilizar un m\u00f3dulo WiFi.</p> <p>En la animaci\u00f3n vemos como utilizar este bot\u00f3n.</p> <p> <p> Gestor de librer\u00edas</p> <p></p>"},{"location":"IDE/caracteristicasIDE2_0/#monitor-serie","title":"Monitor serie","text":"<p>Esta herramienta que habitualmente estaba en una ventana separada ahora se integra en el editor. La herramienta sirve para comunicarse con la placa o para depurar programas.</p> <p>Una ventaja de tener el Serial Monitor integrado con el editor es la posibilidad de tener m\u00faltiples monitores abiertos simult\u00e1neamente. En el editor antiguo, al cambiar el puerto/placa, cambiaba en todas las ventanas. Adem\u00e1s, est\u00e1bamos limitados a una ventana de Serial Monitor, un obst\u00e1culo que el IDE 2.0 elimina.</p> <p>En la animaci\u00f3n vemos el uso b\u00e1sico del mismo.</p> <p> <p> Monitor serie</p> <p>basica</p> <p>Para obtener m\u00e1s informaci\u00f3n sobre Serial Monitor podemos visitar el Serial Monitor tutorial.</p>"},{"location":"IDE/caracteristicasIDE2_0/#serial-plotter","title":"Serial Plotter","text":"<p>Nos permite visualizar datos utilizando gr\u00e1ficos permitiendo monitorizar varias variables de manera simultanea. Para ver mejor el funcionamiento de este elemento vamos a utilizar un potenci\u00f3metro conectado al pin anal\u00f3gico A3 junto con una variable est\u00e1tica y una aleatoria. El c\u00f3digo del ejemplo es:</p> <pre><code>int potenciometro;\nint aleatoria;\nint static_variable = 500;\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\npotenciometro = analogRead(A3);\naleatoria = random(0, 1000);\n  Serial.print(\"Potenciometro:\");\n  Serial.print(potenciometro);\n  Serial.print(\",\");\n  Serial.print(\"Valor aleatorio:\");\n  Serial.print(aleatoria);\n  Serial.print(\",\");\n  Serial.print(\"Variable estatica:\");\n  Serial.println(static_variable);\n}\n</code></pre> <p>En la animaci\u00f3n vemos como cargar el programa y el funcionamiento en la ventana del Serial Plotter.</p> <p> <p> Serial Plotter</p> <p></p>"},{"location":"IDE/caracteristicasIDE2_0/#debugger","title":"Debugger","text":"<p>El depurador se utiliza para probar y depurar programas. B\u00e1sicamente lo que permite es navegar a trav\u00e9s de la ejecuci\u00f3n de un programa, lo que sirve para detectar fallos o errores de c\u00f3digo.</p> <p>El depurador solamente est\u00e1 disponible con las placas SAMD.</p> <p>Tenemos mas informaci\u00f3n en Debugging tutorial.</p>"},{"location":"IDE/caracteristicasIDE2_0/#autocompletado","title":"Autocompletado","text":"<p>Es una nueva caracter\u00edstica de la versi\u00f3n 2.0 muy bien equipada. Debemos tener presente que para que funcione debemos tener seleccionada la placa a utilizar.</p> <p>En la animaci\u00f3n siguiente vemos la herramienta funcionando.</p> <p> <p> Autocompletado</p>"},{"location":"IDE/codigoAB/","title":"C\u00f3digo en Arduinoblocks","text":"<p>La plataforma visual Arduinoblocks tambi\u00e9n nos ofrece algunas opciones para disponer del c\u00f3digo del programa y de las librer\u00edas que se utilizan, opciones que nos pueden resultar de utilidad en especial si no disponemos de bloques para continuar con nuestro programa.</p> <p>En la animaci\u00f3n de la figura siguiente vemos como Arduinoblocks nos permite diferentes opciones de trabajo con el IDE, que son:</p> <ul> <li>Ver c\u00f3digo. Se despliega una ventana con el c\u00f3digo del programa actual cargado.</li> <li>Descargar c\u00f3digo (.ino). Para exportar el c\u00f3digo para utilizarlo en Arduino IDE.</li> <li>ZIP project (.zip). Para exportar el proyecto completo como .zip incluyendo librer\u00edas para Arduino IDE.</li> </ul> <p> <p> Opciones de exportaci\u00f3n de Arduinoblocks</p> <p></p> <p>En el enlace a librer\u00edas podemos descargar el paquete que utiliza ArduinoBlocks e instalarlas todas o la que nos interese en el directorio de librer\u00edas de Arduino. Estas librer\u00edas nos ofrecen una ventaja adicional, y es que son librer\u00edas probadas y que funcionan correctamente.</p>"},{"location":"IDE/descarga/","title":"Descarga","text":"<p>Podemos descargarlo desde la p\u00e1gina de software de Arduino IDE 2.0 y en el momento de creaci\u00f3n de este apartado de la web nos ofrece la versi\u00f3n 2.3.2 adem\u00e1s de los enlaces al editor online, tal y como vemos en la figura siguiente.</p> <p> <p> Descargas</p> <p></p> <p>En esta p\u00e1gina tenemos disponibles las versiones Nightly y otras informaciones importantes como:</p> <ul> <li>La versi\u00f3n de escritorio no est\u00e1 disponible para Chromebook donde deberemos trabajar con el editor web de Arduino.</li> <li>Es posible programar las placas utilizando MicroPython. En la p\u00e1gina MicroPython with Arduino tenemos toda la informaci\u00f3n.</li> <li>Opciones de descarga de versiones anteriores del IDE.</li> <li>T\u00e9rminos de servicio</li> </ul> <p>Si tenemos alguna duda podemos seguir el tutorial en ingl\u00e9s de descarga e instalaci\u00f3n de Arduino IDE 2.0.</p>"},{"location":"IDE/introIDE/","title":"IDE 2 de Arduino","text":"<p>Casi con toda seguridad que se nos va a presentar alguna ocasi\u00f3n en que ArduinoBlocks no satisfaga nuestras necesidades porque no exista el bloque en el momento que lo necesitamos. En estas ocasiones no nos va a quedar mas remedio que recurrir al Entorno de Desarrollo Integrado o IDE de Arduino.</p> <p>Antes de continuar indicar que aqu\u00ed vamos a describir como llevar a cabo los primeros pasos con el IDE 2.0 pero no vamos a tratar conceptos de programaci\u00f3n mediante c\u00f3digo.</p> <p>Vamos a describir como trabajar con el Arduino IDE 2.0 que ofrece mayor rendimiento, una interfaz de usuario mejorada y caracter\u00edsticas nuevas, como el autocompletado , un depurador incorporado y la sincronizaci\u00f3n de bocetos con Arduino Cloud.</p> <p>Todos los tutoriales del Arduino IDE 2 los tenemos en el enlace.</p>"},{"location":"IDE/ventanaIDE/","title":"Ventana principal del IDE 2.0","text":"<p>En la figura siguiente vemos el aspecto que presenta el IDE en la versi\u00f3n 2.0.</p> <p> <p> Arduino IDE 2.0</p> <p></p> <p>A continuaci\u00f3n se describen de forma r\u00e1pida los apartados se\u00f1alados en la figura anterior.</p> <ol> <li>Verify/Upload (Verificar/Cargar): Para compilar y cargar el c\u00f3digo en la placa.</li> <li>Select board &amp; port (Seleccionar placa y puerto): En el desplegable se muestran las placas detectadas de forma autom\u00e1tica, junto con el puerto asignado.</li> <li>Open Serial Plotter (abrir trazador ser\u00ede): Abre la herramienta de graficado como una nueva ventana.</li> <li>Open Serial Monitor (abrir el monitor serie): abre la herramienta Serial Monitor, como una nueva pesta\u00f1a en la consola.</li> <li>Sketchbook (Carpeta de programas): es el directorio o carpeta donde se almacenan localmente los programas. Adem\u00e1s, desde aqu\u00ed se puede sincronizar con Arduino Cloud y tambi\u00e9n obtener los sketch del entorno online.</li> <li>Boards Manager (Administrador de placas): para explorar los paquetes de Arduino y de terceros que se pueden instalar. Por ejemplo, usar una placa MKR WiFi 1010 requiere tener instalado el paquete Arduino SAMD Boards.</li> <li>Library Manager (Ad https://docs.arduino.cc/software/ide-v2./img/teo-basica/soft/ministrador de librer\u00edas): Para navegar por las librer\u00edas propias de Arduino y las creadas por la comunidad.</li> <li>Debugger (Depurador): Para probar y depurar programas en tiempo real.</li> <li>Search (Buscar): b\u00fasqueda de palabras en el c\u00f3digo.</li> </ol>"},{"location":"Imagina/IoT_basico/","title":"Teor\u00eda b\u00e1sica de IoT","text":""},{"location":"Imagina/IoT_basico/#1-que-es-la-internet-de-las-cosas","title":"1.- \u00bfQu\u00e9 es la Internet de las Cosas?","text":"<p>La expresi\u00f3n \u201cInternet de las cosas\u201d o IoT (del ingl\u00e9s, Internet of Things), internet de todas las cosas o internet en las cosas, hace referencia al uso que hacen de Internet los dispositivos conectados (las cosas) para comunicarse sin intervenci\u00f3n humana directa. Tambi\u00e9n se usa el t\u00e9rmino IoT para referirse al conjunto de estos dispositivos conectados comunicando \u201centre m\u00e1quinas\u201d (M2M) sin requerir interacci\u00f3n humana. No existe una Internet especial o diferente para \u201clas cosas\u201d, en principio, se opera con las mismas redes que en otros usos de Internet. En la imagen siguiente se grafica la conexi\u00f3n de elementos con la nube a trav\u00e9s de la red.</p> <p> <p> Conexi\u00f3n de elementos IoT con la nube</p> <p></p> <p>El IoT sirve para monitorizaci\u00f3n y control electr\u00f3nico y toma de decisiones inteligente. Es decir, conectar dispositivos a Internet permite enviar y recibir informaci\u00f3n usando una infraestructura global y as\u00ed poder monitorizar y/o controlar autom\u00e1ticamente y a distancia multitud de contextos. Por ejemplo, en entornos urbanos (ciudades inteligentes) se puede conocer la actividad humana, del medio ambiente, del tr\u00e1fico\u2026 tanto para informar de su estado (como las plazas de aparcamiento disponibles, la densidad o velocidad de la circulaci\u00f3n, la contaminaci\u00f3n\u2026) como para tomar decisiones de forma manual o autom\u00e1tica para optimizar los recursos disponibles (iluminaci\u00f3n, riego de jardines, funcionamiento de los sem\u00e1foros\u2026)</p> <p>Para conectar a la red las placas Arduino, sus clones o basadas en el mismo usaremos los m\u00f3dulos ESP8266. El ESP8266 es un chip de bajo costo Wi-Fi que contiene su propio microcontrolador, un Tensilica L106 de 32-bit. Es un chip de bajo bajo coste y reducido tama\u00f1o. El chip ESP8266 forma parte de multitud de m\u00f3dulos comerciales a trav\u00e9s de diferentes soluciones con distintas funciones, pines, tama\u00f1os y precios.</p> <p> <p> Modelos ESP</p> <p></p> <p>El m\u00e1s simple es el ESP-01, que solo dispone de 2 puertos digitales y necesita un adaptador USB para poder ser programado y es el que vamos a usar aqu\u00ed. Hay otros muchos sistemas como por ejemplo la placa ESP32 STEAMakers de Keyestudio, ESP-12E de ESP8266, la placa de desarrollo NodeMCU, tambi\u00e9n basada en el ESP-12E, Adem\u00e1s, hay placas con WiFi que usan otros chip WiFi diferentes, como la Arduino MKR1000.</p> <p> <p> ESP32 STEAMakers</p> <p> ESP-12E</p> <p> NodeMCU de Keyestudio</p> <p> Arduino MKR1000</p> <p></p>"},{"location":"Imagina/IoT_basico/#2-modulo-esp8266-esp-01","title":"2.- M\u00f3dulo ESP8266 ESP-01","text":""},{"location":"Imagina/IoT_basico/#introduccion","title":"Introducci\u00f3n","text":"<p>El m\u00f3dulo WiFi ESP-01 es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. Actualmente, otros modelos como la ESP-12 o el el ESP32 se est\u00e1n integrando en la mayor\u00eda de placas de desarrollo, cobrando un peso e importancia mucho mayor. Sin embargo, nosotros vamos a asociar nuestro peque\u00f1o ESP-01 a una placa UNO, con el \u00fanico fin de darle conectividad WiFi.</p> <p>El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (veremos a continuaci\u00f3n algunos de ellos) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa TdR STEAM y el ESP8266, consiguiendo as\u00ed conectar a una red WiFi y dar un primer paso de gigantes en el mundo IoT.</p> <p>Veamos el aspecto del ESP-01 y algunas de sus caracter\u00edsticas:</p> <p> Imagen ESP-01 Descripci\u00f3n - ESP8266 es el microcontrolador del m\u00f3dulo ESP-01.- La memoria flash es la BG25Q80A- Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx).- La antena WiFi para la conexi\u00f3n a una internet.- Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026Toda la informaci\u00f3n en el datasheet del fabricante <p></p> <p>Los pines est\u00e1n distribuidos de la siguiente forma:</p> <p> Pines ESP-01 Descripci\u00f3n 1 - GND2 - Pin digital n\u00famero 23 - Pin digital n\u00famero 04 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende.7 - RESET pin a 0V resetea el ESP-01- Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. <p></p> <p>GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales.</p> <p>El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C.</p>"},{"location":"Imagina/IoT_basico/#programacion","title":"Programaci\u00f3n","text":"<p>El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que hemos visto hasta ahora dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que hasta ahora el entorno ArduinoBlocks ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2.</p> <p>Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa.</p> <p>En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios.</p> <p>Aunque sea bastante t\u00e9cnico debemos exponer c\u00f3mo configurar los dos modos de funcionamiento de forma breve.</p> <ul> <li> <p>Modo de funcionamiento UART. Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines:GPIO0 = 0 (nivel bajo o LOW = 0 V).</p> </li> <li> <p>GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc).</p> </li> <li>Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V.</li> </ul> <p>El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado.</p> <ul> <li> <p>Modo de funcionamiento Flash. Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines:</p> </li> <li> <p>GPIO0 = 1</p> </li> <li>GPIO2 = 1</li> </ul> <p>Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados.</p> <p>En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos:</p> <ol> <li>Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. </li> <li>Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines.</li> </ol> <p>Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino o por medio de un convertidor USB-serie igual o similar al de la imagen siguiente:</p> <p> <p> Conversor USB-serial</p> <p></p> <p>Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concActividad el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar.</p>"},{"location":"Imagina/IoT_basico/#3-comando-at-en-el-esp8266","title":"3.- Comando AT en el ESP8266","text":"<p>El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention).</p> <p>Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea  para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa Actividadrno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. <p>En el enlace tenemos un pdf de la empresa Espressif Systems con el juego de comandos AT para el ESP8266.</p> <p>En la tabla siguiente damos un resumen de los comandos con una informaci\u00f3n ampliada de los que vamos a usar para la configuraci\u00f3n inicial que necesitamos.</p> <p> <p> Unos comandos AT</p> <p></p>"},{"location":"Imagina/IoT_basico/#4-preparacion-del-modulo-esp-01","title":"4.- Preparaci\u00f3n del m\u00f3dulo ESP-01","text":"<p>Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot.</p> <p>Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte a la shield del m\u00f3dulo WiFi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo WiFi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la imagen siguiente:</p> <p> <p> Comando AT en consola AB</p> <p></p> <p>Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la siguiente:</p> <p> <p> Respuesta al comando AT</p> <p></p> <p>Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d.</p> <p> <p> Comando AT para establecer velocidad a 9600 baudios</p> <p></p> <p>Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo.</p> <p>Una vez que hemos configurado el m\u00f3dulo WiFi a la velocidad que nos interesa debemos crear un canal en un servidor MQTT donde enviar los datos y visualizarlos. Esto lo vamos a hacer a trav\u00e9s de la web de Thingspeak, pero antes de nada vamos a describir que es MQTT.</p> <p>Para saber mas acerca de la reprogramaci\u00f3n de la velocidad de comunicaci\u00f3n con ESP8266 visita el enlace: Reprogramar la velocidad de comunicaci\u00f3n del ESP8266.</p>"},{"location":"Imagina/IoT_basico/#5-una-introduccion-al-iot-a-traves-de-mqtt","title":"5.- Una introducci\u00f3n al IoT a trav\u00e9s de MQTT","text":"<p>Si queremos trabajar en tareas de IoT debemos de utilizar alg\u00fan protocolo de comunicaci\u00f3n y hoy por hoy el principal es MQTT, pero antes de citar protocolos vamos a tratar algunos conceptos necesarios. Un protocolo de comunicaci\u00f3n no es otra cosa que una serie de normas definidas para que dos o m\u00e1s dispositivos puedan comunicarse entre si de forma comprensible para ambos.</p>"},{"location":"Imagina/IoT_basico/#requisitos-del-iot","title":"Requisitos del IoT","text":"<p>Estamos bastante acostumbrados a realizar un tipo de comunicaci\u00f3n denominada M2M (machine-to-machine) utilizando internet, pero cuando trabajamos en IoT debemos establecer una serie de requisitos que hacen que la comunicaci\u00f3n M2M no sea la mas adecuada. Algunos de estos requisitos son:</p> <ul> <li>Cantidad: se puede llegar a tener un gran n\u00famero de dispositivos diferentes, desde sensores, actuadores, servidores, etc.</li> <li>Escalabilidad: los sistemas deben permitir a\u00f1adir o eliminar dispositivos sin que el sistema global resulte afectado.</li> <li>Variedad: normalmente necesitaremos que el sistema funcione con diferentes sistemas operativos, lenguajes de programaci\u00f3n y el mayor n\u00famero posible de dispositivos.</li> <li>Simultaneidad: gran cantidad de comunicaciones simultaneas, lo que requiere respuestas r\u00e1pidas para lo que es necesario que los mensajes transmitidos sean lo mas cortos posibles.</li> <li>Seguridad: internet no es un sitio muy seguro y estos dispositivos van a estar conectados a internet controlando dispositivos f\u00edsicos.</li> <li>Accesibilidad: tendremos que trabajar en condiciones muy variadas en lo que se refiere a ancho de banda, firewall, direccionamiento,\u2026</li> </ul> <p>La soluci\u00f3n mas com\u00fan consiste en disponer un servidor denominado \u2018broker\u2019, o a veces \u2018Router\u2019, que ser\u00e1 el que reciba los mensajes de los dispositivos emisores y los distribuir\u00e1 a los receptores.</p> <p> <p> Broker</p> <p></p> <p>El broker va a tener una direcci\u00f3n IP fija y ser\u00e1 accesible para todos los dispositivos, puede mantener un registro de los dispositivos conectados, recibir y distribuir mensajes y establecer filtros de destinatarios. Esto permite algo fundamental, y es que cada dispositivo no dependa del resto de dispositivos.</p> <p>Veamos algunos conceptos que nos permitan entender las infraestructuras de los servicios IoT:</p> <ul> <li>Message Queue o cola de mensajes. En este tipo el broker genera una cola de mensajes \u00fanica para cada uno de los clientes que inician la suscripci\u00f3n.</li> <li>Message Service o servicio de mensajer\u00eda. En este tipo el broker distribuye inmediatamente los mensajes filtrados por alg\u00fan criterio a los clientes conectados. A diferencia de Message Queue, los mensajes entregados mientras el cliente est\u00e1 desconectado se pierden. </li> <li>Publish/Susbcribe (PubSub). Se trata de un sistema de mensajer\u00eda donde el 'Subscriber' informa al broker de que quiere recibir un tipo de mensajes y el 'Publisher' entonces puede publicarlos. </li> <li>Router Remoder Procedure Calls (RRPC). Se trata de la ejecuci\u00f3n remota de procedimientos donde 'Callee' comunica al broker que proporciona un procedimiento y el 'Caller', puede llamar a este procedimiento.</li> </ul> <p>Algunos de los protocolos para IoT son:</p> <ul> <li>MQTT (del ingl\u00e9s Message Queuing Telemetry Transport) es un protocolo PubSub de servicio de mensajer\u00eda que act\u00faa sobre TCP. Es ligero y f\u00e1cil de implementar resultando apropiado para dispositivos de baja potencia, tan habituales en IoT. TCP es un protocolo de control de transmisi\u00f3n (del ingl\u00e9s, Transmission Control Protocol) fundamental en Internet.</li> <li>AMQP (Advanced Message Queuing Protocol) es un protocolo PubSub de cola de mensajes que asegura la confiabilidad e interoperabilidad necesaria en aplicaciones corporativas.</li> <li>STOMP (Streaming Text Oriented Messaging Protocol). Es un protocolo sencillo que emplea HTTP y mensajes de texto.</li> <li>XMPP (Extensible Messaging and Presence Protocol). Es un protocolo abierto basado en XML dise\u00f1ado para aplicaciones de mensajer\u00eda instant\u00e1nea.</li> <li>WAMP (Web Application Messaging Protocol). Es un protocolo abierto que se ejecuta sobre WebSockets, y provee tanto aplicaciones de PubSub como RRPC.</li> <li>CoAP (Constrained Application Protocol) es un protocolo pensado para emplearse en dispositivos de IoT de baja capacidad.</li> </ul>"},{"location":"Imagina/IoT_basico/#mqtt","title":"MQTT","text":"<p>Dentro de una arquitectura de MQTT, es muy importante el concepto topic (tema en espa\u00f1ol) ya que la comunicaci\u00f3n se realiza a trav\u00e9s de topics debiendo estar los emisores y receptores subscritos a un topic com\u00fan para poder establecer la comunicaci\u00f3n. Este tipo de arquitectura permite que la comunicaci\u00f3n pueda ser de uno a uno o de uno a muchos.</p> <p>Los topics tienen estructura jer\u00e1rquica pudiendo establecer relaciones padre-hijo de manera que cuando nos suscribimos a un topic padre podemos recibir tambi\u00e9n la informaci\u00f3n de sus hijos. En un ejemplo lo podemos ver m\u00e1s claramente.</p> <p> <p> Estructura jerarquica de un topic</p> <p></p> <p>Un topic se representa mediante una cadena con las jerarquias separadas por /. Por ejemplo:</p> <ul> <li>Vivienda/Planta baja/Cocina/Arduino/Luz</li> <li>Vivienda/Planta alta/Dorm.1/Arduino/Temperatura.</li> </ul> <p>De esta forma podemos suscribirnos a un topic concActividad o a varios, por ejemplo:</p> <ul> <li>Un topic: Vivienda/Planta baja/Cocina/Arduino/Luz</li> <li>Varios topics: Vivienda/Planta baja/#</li> </ul> <p>Existen b\u00e1sicamente tres tipos de brokers, los privados, los p\u00fablicos y los locales. A continuaci\u00f3n citamos alguno de los m\u00e1s utilizados:</p> <p>a.- Private MQTT Broker: solamente los dispositivos que establezcamos pueden publicar o suscribirse a un topic. Se utiliza en producci\u00f3n y prototipado. Algunos de ellos son:</p> <ul> <li>Azure de Microsoft.</li> <li>AWS de Amazon.</li> <li>CloudMQTT disponible en: https://www.cloudmqtt.com/plans.html.</li> <li>ThingSpeak de Mathworks (MATLAB).</li> </ul> <p>b.- Public MQTT Broker: cualquier dispositivo puede publicar y suscribirse a topics. Algunos de ellos son:</p> <ul> <li>Eclipse</li> <li>Mosquitto</li> <li>HiveMQ: Enlace - Direcci\u00f3n del broker</li> <li>Flespi</li> <li>Dioty</li> <li>Fluux</li> <li>Thingspeak</li> </ul> <p>Si queremos instalar nuestro propio broker en una raspberry o PC, sin duda Mosquito es la opci\u00f3n m\u00e1s extendida.</p>"},{"location":"Imagina/IoT_basico/#6-creacion-de-un-canal-en-un-servidor-mqtt","title":"6.- Creaci\u00f3n de un canal en un servidor MQTT","text":"<p>En nuestro caso vamos a utilizar Thingspeak en su versi\u00f3n p\u00fablica. Lo primero que debemos hacer es crear una cuenta, para lo que clicamos en Sign Up. Seguidamente, introducimos un correo electr\u00f3nico v\u00e1lido y el resto de datos que nos pide. Lo vemos en la imagen siguiente:</p> <p> <p> Pagina inicial de Thingspeaks</p> <p></p> <p>Debemos aceptar que use la direcci\u00f3n de correo electr\u00f3nico para nuestra cuenta de MathWorks, como se ve en la imagen siguiente:</p> <p> <p> Aceptaci\u00f3n a Mathwork</p> <p></p> <p>Tras esto recibiremos un correo en la direcci\u00f3n que hemos dado para confirmar la creaci\u00f3n de la cuenta y confirmarla. Debemos ver algo similar a la imagen siguiente:</p> <p> <p> Confirmacion aceptaci\u00f3n cuenta correo</p> <p></p> <p>Una vez confirmada la direcci\u00f3n de correo electr\u00f3nico, volvemos a la p\u00e1gina donde est\u00e1bamos y hacemos click en continuar. Nos pedir\u00e1 un nombre de usuario y una contrase\u00f1a que usaremos a partir de ahora para iniciar sesi\u00f3n.</p> <p>Finalizada la creaci\u00f3n de la cuenta iniciamos sesi\u00f3n desde la p\u00e1gina principal haciendo clic en \u201cSign In\u201d. Veremos una ventana como la de la imagen siguiente:</p> <p> <p> Ventana para identificaci\u00f3n en Thingspeaks</p> <p></p> <p>Escribimos nuestra contrase\u00f1a y hacemos clic en el bot\u00f3n Sign in.</p> <p> <p> Acceso a Thingspeaks</p> <p></p> <p>Con esto entramos en el broker y est\u00e1 todo listo para iniciar el trabajo.</p> <p> <p> Acceso correcto al broker</p> <p></p> <p>Podemos aprender mas sobre el tema visitando los siguientes enlaces:</p> <ul> <li>Primeros pasos con Wifi: Servidor sin clave y contrase\u00f1a</li> <li>Wifi con servidor gratuito con clave y contrase\u00f1a y app m\u00f3vil</li> </ul>"},{"location":"Imagina/IoT_basico/#7-filtrado-por-mac","title":"7.- Filtrado por MAC","text":"<p>Si por cualquier motivo nuestra red WiFi tiene filtrado MAC debemos de dar de alta en la misma de nuestro dispositivo ESP-01. Esta es una tarea que va a depender de nuestro router y suministrador y que no resulta especialmente complicada. Lo primero que debemos hacer es averiguar la direcci\u00f3n MAC de nuestro dispositivo ESP8266. Esta tarea no la vamos a hacer desde ArduinoBlocks sino que vamos a recurrir al IDE de Arduino.</p> <p>Si necesitas ayuda para este tema seguro que la encuentras en estos tutoriales de Luis Llamas, o tambi\u00e9n puedes buscar informaci\u00f3n en tu navegador pues existen multitud de p\u00e1ginas referentes al tema de programaci\u00f3n desde el IDE de Arduino.</p> <p>Los elementos que vamos a utilizar para conectar nuestro m\u00f3dulo ESP-01 a la placa TdR STEAM los vemos en la imagen siguiente:</p> <p> Shield WiFi serial M\u00f3dulo ESP-01 Conector de comunicaciones en la TdR STEAM Cables tipo Dupont M-H <p></p>"},{"location":"Imagina/IoT_basico/#conexionado","title":"Conexionado","text":"<p>Nos encontramos con el problema de que el orden de pines en el conector de la TdR STEAM (RX-TX-GND-VCC) no coinicede con el de la Shield WiFi serial (RX-TX-VCC-GND) por lo que no lo vamos a poder \"pinchar\" directamente en el conector y debemos utilizar cables tipo Dupont.</p> <p>Debemos tener muy presente que la placa  TdR STEAM ya realiza una conexi\u00f3n cruzada entre los pines Tx y Rx, es decir:</p> <ul> <li>Rx de la TdR STEAM va conectada a Tx de la placa UNO</li> <li>Tx de la TdR STEAM va conectada a Rx de la placa UNO</li> </ul> <p>En la imagen siguiente vemos gr\u00e1ficamente como debemos hacer el conexionado al que nos estamos refiriendo.</p> <p> <p> Conexi\u00f3n NO CRUZADA TdR - Shield</p> <p></p> <p>Para nuestro prop\u00f3sito de comunicar el ordenador con el ESP-01 a trav\u00e9s del IDE y averiguar la MAC de nuestro dispositivo creo que lo mas conveniente y claro es realizar el montaje que vemos en la imagen siguiente:</p> <p> <p> Conexi\u00f3n cruzada UNO a Shield wifi</p> <p></p> <p>En este caso si es totalmente imprescindible realizar la conexi\u00f3n cruzada mostrada en la imagen entre Tx y Rx.</p>"},{"location":"Imagina/IoT_basico/#comunicacion-entre-pc-y-esp01","title":"Comunicaci\u00f3n entre PC y ESP01","text":"<p>Con la conexi\u00f3n cruzada descrita y un sketch vac\u00edo en el IDE que subimos a la placa UNO, conectamos el UNO al ordenador y establecemos la configuraci\u00f3n de nuestra placa UNO y el puerto USB al que estamos conectados. Lo que en realidad hacemos es usar la placa UNO como un convertidor bidireccional USB a RS232 que nos permite comunicar el ordenador con la placa ESP8266 ESP01. Abrimos el monitor serie desde el IDE de Arduino y lo configuramos como vemos en la imagen siguiente:</p> <p> <p> Configuraci\u00f3n del monitor serie</p> <p></p> <p>Escribimos AT y pulsamos Enter o hacemos clic en Enviar y el m\u00f3dulo deber\u00e1 responder OK si todo es correcto. Si la velocidad por defecto del m\u00f3dulo no es de 115200 no responder\u00e1 y posiblemente se vean caracteres extra\u00f1os en el monitor serie. En este caso habr\u00e1 que probar distintas velocidades hasta conseguir que el m\u00f3dulo responda OK al comando AT. El resultado correcto lo vemos en la imagen siguiente:</p> <p> <p> Comando AT OK</p> <p></p>"},{"location":"Imagina/IoT_basico/#direccion-mac","title":"Direcci\u00f3n MAC","text":"<p>El \u00faltimo paso es teclear el comando AT para conseguir la direcci\u00f3n f\u00edsica o MAC del dispositivo conectado. Este comando es AT+CIFSR y es que el que vemos en la imagen siguiente:</p> <p> <p> Comando AT para obtener la MAC</p> <p></p> <p>El comando AT+CIFSR nos devuelve un resultado similar al que vemos en la imagen siguiente:</p> <p> <p> MAC obtenida</p> <p></p> <p>Ya podemos dar de alta la MAC del dispositivo en nuestro filtrado MAC y poder as\u00ed comunicarnos a trav\u00e9s de WiFi.</p>"},{"location":"Imagina/actividades/","title":"Actividades b\u00e1sicas con la placa Imagina 3DBot","text":"<p>Utilizaremos la placa Imagina 3DBot como shield de la ESP32 STEAMakers.</p> <p>En todas las actividades es muy importane tener presente el siguiente aviso:</p> <p> <p> Aviso</p> <p></p>"},{"location":"Imagina/actividades/#a01-encender-un-led","title":"A01. Encender un LED","text":"<p>Trabajaremos con los LEDs que vemos en la imagen siguiente:</p> <p> <p> Diodos LED</p> <p></p>"},{"location":"Imagina/actividades/#a01_1-activar-un-led-como-indicativo-de-que-todo-va-bien","title":"A01_1. Activar un LED como indicativo de que todo va bien","text":"<p>En el apartado \"3dBot\" de Arduinoblocks encontraremos el bloque \"Led\", que nos permite encender y apagar los LED verde, amarillo y rojo de la Imagina 3DBot.</p> <p> <p> A01_1. Activar un LED</p> <p></p> <p>El LED se enciende totalmente introduciendo un 255 en la parte derecha del bloque. Para apagarlo basta con poner un 0. Tambi\u00e9n se puede variar la intensidad de brillo. Para ello, cualquier valor entre 0 y 255 har\u00e1 que el brillo del LED aumente proporcionalmente hasta alcanzar su m\u00e1ximo en 255.</p> <p> <p> A01_1. Activar un LED Acceder al programa</p> <p></p> <p>Despu\u00e9s de cargar este programa, el LED rojo tendr\u00e1 que permanecer encendido indefinidamente a la mitad de su brillo. Si es as\u00ed, tienes bien conectada la placa y has conseguido cargar tu primer programa. \u00a1Seguimos!</p>"},{"location":"Imagina/actividades/#a01_2-juego-de-luces-con-bloque-espera","title":"A01_2. Juego de luces con bloque \u201cEspera\u201d","text":"<p>El bloque \u201cEsperar\u201d lo podemos encontrar en el apartado \u201cTiempo\u201d. Se corresponde con el famoso delay. Lo que hacemos al insertar un bloque \u201cEsperar\u201d es dejar la placa en el estado en el que se encontraba justo antes de la espera durante el tiempo que \u00e9sta dure, es decir, se detiene el procesador durante ese tiempo.</p> <p> <p> A01_2. Bloque esperar</p> <p></p> <p>Cuidado, porque el tiempo utilizado en este bloque est\u00e1 en milisegundos, por lo que para esperar, por ejemplo medio segundo, deberemos introducir un 500.</p> <p>Programa ejemplo:</p> <p> <p> A01_2. Juego de luces</p> <p>Acceder al programa</p> <p></p> <p>Con este programa conseguimos que el LED verde parpadee con una frecuencia de 1 segundo de encendido y apagado. Puedes intentar cambiar tiempo e introducir m\u00e1s LED, as\u00ed como variar su intensidad de brillo.</p> <p>El problema de la funci\u00f3n Esperar es que deja la placa bloqueada en el estado anterior durante este tiempo de espera, es decir, no recibe ni env\u00eda nuevas \u00f3rdenes durante este tiempo. Por eso, en ciertos casos, es m\u00e1s conveniente utilizar el bloque \u201cEjecutar cada\u201d que veremos en futuros apartados.</p>"},{"location":"Imagina/actividades/#a02-encender-un-led-con-el-pulsador","title":"A02. Encender un LED con el pulsador","text":"<p>Los componentes implicados los vemos en la imagen siguiente:</p> <p> <p> A02. Componentes utilizados</p> <p></p> <p>En esta actividad queremos encender el LED verde al presionar el pulsador de la placa. Para ello debemos empezar a utilizar funciones del men\u00fa \"L\u00f3gica\" con las funciones de condici\u00f3n.</p> <p>Condiciones \u201cSi \u2026 hacer \u2026\u201d <p>Se trata del famoso bucle <code>if</code>, que es uno de los pilares de la programaci\u00f3n, puesto que permite evaluar estados y tomar decisiones en consecuencia.</p> <p>Funciona como una oraci\u00f3n condicional: si se cumple la condici\u00f3n incluida en su primer apartado, entonces se realiza la acci\u00f3n incluida en su segundo apartado. De lo contrario, no se hace nada.</p> <p> <p> A02. Condicional <code>Si ... hacer</code></p> <p></p> <p>Para el programa ejemplo vamos a utilizar un nuevo bloque que controla el pulsador que incorpora la placa Imagina 3dBot. Lo podemos encontrar en el apartado \"3dBot\".</p> <p> <p> A02. Bloque 'Bot\u00f3n se ha pulsado'</p> <p></p> <p>Con este bloque crearemos la condici\u00f3n. Como acci\u00f3n a ejecutar si se cumple la condici\u00f3n, vamos a encender un LED. Para ello volveremos a utilizar wl bloque 'Led' que localizamos en la misma secci\u00f3n que el pulsador.</p>"},{"location":"Imagina/actividades/#a02_1-al-pulsar-el-boton-se-enciende-un-led","title":"A02_1. Al pulsar el bot\u00f3n se enciende un LED","text":"<p> <p> A02_1. Al pulsar el bot\u00f3n se enciende un LED</p> <p>Acceder al programa</p> <p></p> <p>Ampliando el condicional <p>Otros bloques condicionales: <code>si... hacer... si no...</code> o <code>si... hacer... si no si... hacer....</code></p> <p>El bloque <code>si \u2026 hacer \u2026 si no \u2026</code> est\u00e1 en \u201cL\u00f3gica\u201d:</p> <p> <p> A02. Bloque <code>si... hacer... si no...</code></p> <p></p> <p>La ampliaci\u00f3n de los bloques, como el bloque <code>si... hacer... si no si... hacer....</code> se consigue haciendo clic sobre el signo mas de la esquina superior izquierda. Vemos el proceso en la animaci\u00f3n siguiente:</p> <p> <p> A02. Ampliar los bloques l\u00f3gicos</p> <p></p> <p>Veremos ejemplos del uso de estas variantes a lo largo de distintos programas.</p> <p>Pero siguiendo con el ejemplo del LED, realizaremos un programa que al pulsar el bot\u00f3n se encienda el LED durante un segundo; si no se acciona el pulsador, se apagar\u00e1 el LED.</p>"},{"location":"Imagina/actividades/#a02_2-ampliando-el-condicional","title":"A02_2. Ampliando el condicional","text":"<p> <p> A02_2. Ampliando el condicional</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/actividades/#a03-medir-la-luminosidad-con-la-ldr","title":"A03. Medir la luminosidad con la LDR","text":"<p>Anteriormente hemos comentado que existe la funci\u00f3n \"Ejecutar cada\". Aprovecharemos esta funci\u00f3n junto con la funci\u00f3n \u201cEnviar\u201d para ver los datos del sensor de luminosidad en la pantalla del ordenador. Pero antes de realizar el ejercicio vamos a ver las diferentes funciones poco a poco.</p> <ul> <li>Gesti\u00f3n de tiempo con el bloque \u201cEjecutar cada\u201d Encontraremos el bloque en la secci\u00f3n \u201cTiempo\u201d. Este bloque ejecuta una vez cada X tiempo los comandos que se encuentren dentro de \u00e9l. Cuidado, porque NO detiene el programa en el estado anterior a \u00e9l, como s\u00ed lo hace el bloque \u201cEsperar\u201d.</li> </ul> <p> <p> A03. Bloque <code>Ejecutar cada</code></p> <p></p> <p>Junto a \"Enviar\", es una funci\u00f3n muy \u00fatil para mostrar datos en el ordenador. Vamos a verlo con un ejemplo en el siguiente apartado, en el que aprenderemos a enviar datos desde Imagina 3dBot con la placa ESP32 STEAMakers al ordenador.</p> <ul> <li>Imprimir en el puerto serie (enviar datos al ordenador) En la secci\u00f3n \u201cComunicaciones \u2192 Puerto serie\u201d tenemos el bloque \u201cEnviar\u201d, mediante el cual enviamos valores a la pantalla del ordenador.</li> </ul> <p> <p> A03. Bloque <code>Enviar</code></p> <p></p> <p>Podemos enviar cualquier orden o dato que queramos s\u00f3lo introduci\u00e9ndolo en el espacio en blanco entre comillas del bloque.</p> <ul> <li>Programa ejemplo </li> </ul> <p> <p> Enlace a ejemplo 3DB_Ej10</p> <p></p> <p>Con este programa lo que hacemos es enviar a la pantalla del ordenador las palabras \"Imagina 3dBot\" una vez por segundo (1000 ms).</p> <p>Despu\u00e9s de cargar el programa, pulsando el bot\u00f3n \u201cConsola\u201d y a continuaci\u00f3n \u201cConectar\u201d veremos en la pantalla del ordenador los valores enviados:</p> <p> <p> Ejemplo 3DB_Ej10: Consola</p> <p></p> <p>Cabe destacar que, si no utilizamos el bloque \u201cEjecutar cada\u201d, enviamos al ordenador un dato cientos de veces por segundo, lo que satura la comunicaci\u00f3n y bloquea el sistema. De ah\u00ed la importancia de este bloque.</p> <p>Tambi\u00e9n podr\u00edamos utilizar el bloque \u201cEsperar\u201d para enviar datos cada segundo, pero entonces, en tiempos de espera, la placa no podr\u00eda escuchar otros comandos ni realizar otras acciones. Tranquilos, veremos esto m\u00e1s adelante con calma\u2026 \u00a1y con m\u00e1s ejemplos!</p> <p>Ahora vamos a aplicar estos dos conceptos para leer los valores del sensor LDR incorporado en la placa.</p> <p>En esta actividad se pretende que, cuando oscurezca, se encienda el LED amarillo, como si de una sonda crepuscular se tratara.</p> <p>Los componentes implicados los vemos en la imagen siguiente:</p> <p> <p> A03. Componentes utilizados</p> <p></p> <p>Para ello vamos a utilizar el bloque de la LDR (Resistencia Dependiente de la Luz) como dato para enviar a la pantalla del ordenador.</p> <p> <p> A03. Bloque \"Sensor de luz\"</p> <p></p> <p>Introducimos el siguiente programa y abrimos la consola:</p> <p> <p> A03_1. Medir la luminosidad con la LDR</p> <p>Acceder al programa</p> <p></p> <p> <p> A03_1. Medir la luminosidad con la LDR: Consola</p> <p></p> <p>Comprueba su funcionamiento observando como c\u00f3mo cambia de valor si tapamos el sensor con el dedo y nos permite saber el valor con luz ambiental o a oscuras.</p> <p>\u00bfC\u00f3mo podr\u00edamos hacer para que se active el LED amarillo a partir de cierto nivel de luz?</p> <p> <p> A03_2. Interruptor crepuscular</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/actividades/#a04-medida-de-la-temperatura-con-la-ntc","title":"A04. Medida de la temperatura con la NTC","text":"<p>En esta pr\u00e1ctica realizaremos un detector de incendios, de forma que deber\u00e1 encenderse el LED rojo cuando se supere un determinado valor del sensor de temperatura.</p> <p>El sensor de temperatura que utilizamos es de tipo anal\u00f3gico, y se llama NTC (Coeficiente de Temperatura Negativo).</p> <p>Los componentes implicados los vemos en la imagen siguiente:</p> <p> <p> A04. Componentes utilizados</p> <p></p> <p>Aprovecharemos para introducir el concepto de variable.</p> <p>Las variables son elementos comunes en programaci\u00f3n. B\u00e1sicamente, crear una variable es dar un nombre a un dato o lectura. Por ejemplo, las medidas de valores de temperatura se pueden guardar en una variable llamada \u201cTemperatura\u201d. No es obligatorio su uso, pero nos permite trabajar m\u00e1s c\u00f3modamente. Adem\u00e1s, puesto que podemos personalizar su nombre, ayudan a clarificar el c\u00f3digo y utilizar un lenguaje m\u00e1s natural.</p> <p>Hay 3 tipos de variables distintas que son:</p> <ul> <li>N\u00famero: son variables para n\u00fameros (como indica el nombre de la variable) Texto: son variables para texto (como indica el nombre de la variable)</li> <li>Booleana: son variables para datos digitales que s\u00f3lo pueden ser 0 y 1</li> </ul> <p>Para crear una variable escogemos el tipo y le ponemos un nombre, lo que hacemos de la forma siguiente:</p> <p> <p> A04. Crear, renombrar y eliminar variables</p> <p></p> <p>As\u00ed tenemos la variable creada, lo que nos ofrece dos nuevos bloques:</p> <ul> <li>El bloque donde damos valor a la variable</li> </ul> <p> <p> A04. Bloque para asignar valor a variable</p> <p></p> <ul> <li>Y el bloque de la propia variable creada, para poder insertarla y combinarla con otros bloques.</li> </ul> <p> <p> A04. Bloque con el valor de la variable</p> <p></p>"},{"location":"Imagina/actividades/#a04_1-medir-el-valor-de-temperatura-ambiente","title":"A04_1. Medir el valor de temperatura ambiente","text":"<p>De forma totalmente similar a como hemos realizado la actividad de la luminosidad vamos a descubir el valor de la temperatura.</p> <p> <p> A04_1. Medir la temperatura ambiente</p> <p>Acceder al programa</p> <p></p> <p>Podemos observar en la consola como el sensor devuelve el valor de la temperatura ambiente con dos cifras decimales.</p>"},{"location":"Imagina/actividades/#a04_2-detector-de-temperatura-elevada","title":"A04_2. Detector de temperatura elevada","text":"<p>Vamos a hacer que cuando se superen los 30 \u00baC se encienda el LED rojo y que suene una sirena en el zumbador.</p> <p> <p> A04_2. Detector de temperatura elevada</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/actividades/#a05-medir-distancias-con-el-sensor-hc-sr04","title":"A05. Medir distancias con el sensor HC-SR04","text":"<p>Si disponemos de un sensor de ultrasonidos HC-SR04 podremos realizar medidas de distancia directamente con Arduinoblocks.</p> <p>El funcionamiento de los sensores de ultrasonidos consiste en emitir un ultrasonido y medir el tiempo que tarda en rebotar con el objeto que tiene delante y volver. As\u00ed se puede calcular la distancia a la que se encuentra el objeto que est\u00e1 delante y sobre el que ha rebotado el sonido.</p> <p>Para realizar esta pr\u00e1ctica lo conectaremos directamente al z\u00f3calo delantero como se ve en la imagen.</p> <p> <p> A05. Colocaci\u00f3n del sensor HC-SR05</p> <p></p> <p>El bloque 'Distancia' del men\u00fa 3DBot nos va a permitir trabajar de forma sencilla con el sensor.</p> <p> <p> A05. Bloque 'Distancia'</p> <p></p>"},{"location":"Imagina/actividades/#a05_1-medir-distancia","title":"A05_1. Medir distancia","text":"<p>El programa que nos mostrar\u00e1 las distancia por consola ser\u00eda el siguiente:</p> <p> <p> A05_1. Medir distancia</p> <p>Acceder al programa</p> <p></p> <p>En la consola vemos diferentes distancias medidas.</p> <p> <p> A05_1. Medir distancia</p> <p></p>"},{"location":"Imagina/actividades/#a05_2-sensor-de-aparcamiento-de-un-coche","title":"A05_2. Sensor de aparcamiento de un coche","text":"<p>La placa emitir\u00e1 un aviso sonoro intermitente cuya frecuencia depender\u00e1 de la distancia a la que est\u00e9 un objeto que se coloque por delante. Cuanto m\u00e1s cerca est\u00e9, m\u00e1s veces por segundo sonar\u00e1.</p> <p>Hay que tener en cuenta que el tiempo que pasa entre aviso y aviso (que depende de la distancia) se indica en milisegundos. Por eso multiplicamos por un factor (en el ejemplo, 15) que hace que la frecuencia de aviso se adapte a nuestras necesidades. Puedes probar el sistema, variarlo, escalarlo y adaptarlo a tu antojo.</p> <p> <p> A05_2. Sensor de aparcamiento de un coche</p> <p>Acceder al programa</p> <p></p> <p>Vemos en el programa que la frecuencia con que se hace cada ciclo, equivale a la frecuencia con la que damos cada aviso, que depende directamente de la distancia del sensor al objeto.</p>"},{"location":"Imagina/actividades/#a05_3-sensor-de-distancia","title":"A05_3. Sensor de distancia","text":"<p>En el programa anterior existe un inconveniente, y es que la placa siempre dar\u00e1 avisos, aunque el objeto que est\u00e9 delante se encuentre a mucha distancia. Ahora vamos a poner una nueva condici\u00f3n para que ese aviso s\u00f3lo comience cuando el objeto se encuentre a una determinada distancia m\u00ednima. Para el ejemplo que se propone se ha probado con 20 cm, pero al igual que antes puede ajustarlo como quieras.</p> <p> <p> A05_3. Sensor de distancia</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/actividades/#a06-generador-de-notas-musicales-con-el-zumbador","title":"A06. Generador de notas musicales con el zumbador","text":"<p>El zumbador es el peque\u00f1o \u201caltavoz\u201d situado en una de las esquinas de la placa, junto a los LED, y con \u00e9l podemos generar melod\u00edas musicales.</p> <p> <p> A06. Generador de notas musicales con el zumbador</p> <p></p> <p>Uno de los par\u00e1metros que caracterizan a un sonido es su frecuencia de emisi\u00f3n, siendo la frecuencia el n\u00famero de veces que se repite por unidad de tiempo (segundo). La transmisi\u00f3n del sonido se realiza por ondas a trav\u00e9s en cualquier medio (s\u00f3lido, l\u00edquido o gaseoso) excepto en el vac\u00edo. La frecuencia de un sonido nos indica cuantos ciclos por segundo tiene una onda.</p> <p>En la imagen y la tabla siguientes vemos un dibujo con un fragmento de las teclas de un piano estando todo referido a una nota est\u00e1ndar, la nota \"La\" central que tiene una frecuencia de 440 Hz. Podemos ver la nota musical que reproduce, en las dos notaciones m\u00e1s comunes de los sonidos (Ingl\u00e9s: C D E F G A B, Alem\u00e1n: C D E F G A H, Espa\u00f1ol, italiano y franc\u00e9s: Do Re Mi Fa Sol La Si) y adem\u00e1s se encuentra la frecuencia que produce esa nota musical.</p> <p> <p> A06. Secci\u00f3n de piano y notas</p> <p></p> <p>Los bloques que tenemos disponibles para programar sonidos son:</p> <p> <p> A06. Bloques sonido</p> <p></p>"},{"location":"Imagina/actividades/#a06_1-notas-musicales","title":"A06_1. Notas musicales","text":"<p>En el programa siguiente se reproducen todas las notas musicales bien especificando la frecuencia o bien especificando la nota.</p> <p> <p> A06_1. Notas musicales</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/actividades/#a06_2-melodias","title":"A06_2. Melodias","text":"<p>Si no se pulsa el bot\u00f3n suena una melodia y mientras se mantiene pulsado suena otra.</p> <p> <p> A06_2. Melodias</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/actividades/#a07-funciones","title":"A07. Funciones","text":"<p>Una funci\u00f3n es simplemente un conjunto de instrucciones a las que damos un nombre, para no tener que repetirlas en distintas partes del programa y para clarificar y ordenar el c\u00f3digo. Al crear una funci\u00f3n se genera autom\u00e1ticamente un bloque, que ya puede ser insertado en cualquier parte del programa.</p> <p>Para ello, debemos utilizar el bloque \u201chacer algo\u201d que encontramos en el apartado \u201cFunciones\u201d de Arduinoblocks.</p> <p> <p> A07. Bloques \u201chacer algo\u201d</p> <p></p> <p>Primero debemos dar un nombre a la funci\u00f3n e incluir el conjunto de instrucciones que queremos que haga la placa cada vez que la utilicemos.</p> <p>Por ejemplo, podemos definir una funci\u00f3n con el nombre \u201cLuz 1\u201d cuya finalidad sea encender el LED verde y apagar el amarillo y el rojo.</p> <p> <p> A07. Funci\u00f3n Luz 1</p> <p></p> <p>Si ahora vamos a la secci\u00f3n \u201cFunciones\u201d del panel izquierdo de Arduinoblocks, encontraremos ya la nueva funci\u00f3n creada, disponible para ser seleccionada e insertada en cualquier parte del c\u00f3digo:</p> <p> <p> A07. Funci\u00f3n Luz 1</p> <p></p> <p>Es importante destacar que las funciones no se definen dentro de \u201cBucle\u201d. Se crean fuera y despu\u00e9s se insertan en los momentos en los que queramos que se ejecuten.</p> <p>Cuando creamos un programa peque\u00f1o (de pocos bloques), no suele valer la pena definir funciones. Pero cuando hacemos programas m\u00e1s extensos o con partes iguales que se repiten, es una buena pr\u00e1ctica su uso, tanto por comodidad como por claridad del programa realizado.</p>"},{"location":"Imagina/actividades/#a07_1-juegos-de-luces","title":"A07_1. Juegos de luces","text":"<p>En el siguiente programa se definen 3 funciones, creando juegos de luces con los 3 LED de la placa, y a continuaci\u00f3n se realiza una secuenciaci\u00f3n y repetici\u00f3n de \u00e9stas.</p> <p>Las funciones \u201cLuz 1\u201d, \u201cLuz 2\u201d y \u201cLuz 3\u201d son:</p> <p> <p> A07. Funciones Luz 1, Luz 2 y Luz 3</p> <p></p> <p>Despu\u00e9s de crear las funciones ya las podemos encontrar en el apartado \u201cFunciones\u201d, como bloques, para insertarlas en el \u201cBucle\u201d.</p> <p>El programa completo queda as\u00ed:</p> <p> <p> A07_1. Juegos de luces</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/actividades/#a07_2-juegos-de-luces-con-sonido","title":"A07_2. Juegos de luces con sonido","text":"<p>Siguiendo el programa anterior, vamos a a\u00f1adir unos sonidos a las funciones con el bloque Zumbador. Para que siga a la misma velocidad, ahora eliminamos los tiempos de espera del bucle, ya que el zumbador ya incluye ese tiempo de espera.</p> <p> <p> A07_2. Juegos de luces con sonido</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/actividades/#a08-infrarrojos","title":"A08. Infrarrojos","text":"<p>Los infrarrojos son una clase de radiaci\u00f3n electromagn\u00e9tica con una longitud de onda que resulta superior a la longitud de onda de la luz visible, siendo su frecuencia superior a las microondas. Dentro del espectro electromagn\u00e9tico, la radiaci\u00f3n infrarroja se encuentra comprendida entre el espectro de luz visible y las microondas. Tiene longitudes de onda mayores o m\u00e1s largas que el rojo. En la imagen siguiente, obtenida del blog de Mercedes Gonz\u00e1lez Mas vemos caracterizados los infrarrojos dentro del espectro.</p> <p> <p> A08. Espectro electromagnetico</p> <p></p> <p>Como podemos observar en la imagen, los rayos infrarrojos son clasificados, de acuerdo a su longitud de onda, del siguiente modo:</p> <ul> <li>infrarrojo cercano, con longitud de onda entre 0.7 \u00b5m y 1.1 \u00b5m, es la parte del espectro infrarrojo que ese encuentra m\u00e1s pr\u00f3ximo a la luz visible.</li> <li>infrarrojo medio, con longitud de onda entre 1,1 \u00b5m y 15 \u00b5m.</li> <li>infrarrojo lejano o regi\u00f3n m\u00e1s cercana a las microondas, con longitud de onda entre 15 \u00b5m y 100 \u00b5m</li> </ul> <p>En la imagen siguiente, obtenida de wikipedia, sobre espectro electromagn\u00e9tico podemos ver m\u00e1s informaci\u00f3n del tema.</p> <p> <p> A08. Espectro electromagnetico</p> <p></p> <p>Todos los cuerpos emiten una cierta cantidad de radiaci\u00f3n, y aunque esta resulta invisible para el ojo humano, existen dispositivos electr\u00f3nicos capaces de \"verla\" por estar dise\u00f1ados para ello.</p> <p>Receptor de infrarrojos <p>Un diodo receptor de infrarrojos t\u00edpico de 38 KHz tiene el siguiente aspecto:</p> <p> <p> A08. Diodo receptor de infrarrojos</p> <p></p> <p>En la placa Imagina 3DBot se localiza en la posici\u00f3n que observamos en la imagen siguiente:</p> <p> <p> A08. Diodo receptor de infrarrojos en la Imagina 3DBot</p> <p></p> <p>El dispositivo sirve para controles remotos universales y utiliza la codificaci\u00f3n NEC. El receptor de infrarrojos permite codificar los protocolos de se\u00f1ales de pulsos infrarrojos utilizados por los mandos a distancia. Los protocolos detectados son los siguientes: RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA, LG, SANYO, MITSUBISHI y DENON. Es decir, detectar\u00eda cualquier se\u00f1al emitida por cualquiera de esos mandos.</p> <p>Emisor de infrarrojos <p>En nuestro caso como emisor de infrarrojos vamos a utilizar el control remoto de Keyestudio que vemos en la imagen siguiente:</p> <p> <p> A08. Control remoto de Keyestudio</p> <p></p> <p>El mini control remoto tiene 17 teclas de funci\u00f3n y tiene las siguientes especificaciones:</p> <ul> <li>Bater\u00eda: pilas de bot\u00f3n CR2025</li> <li>Distancia de transmisi\u00f3n: hasta 8 m</li> <li>\u00c1ngulo efectivo: 60\u00b0</li> </ul> <p>El control remoto, o mando a distancia, por IR funciona emitiendo trenes de pulsos de luz infrarroja. Diferentes se\u00f1ales corresponden a botones diferentes La se\u00f1al infrarroja transmite el c\u00f3digo correspondiente al bot\u00f3n del mando a distancia pulsado al dispositivo en forma de una serie de impulsos de luz infrarroja. El receptor recibe la serie de impulsos de infrarrojos y los pasa a un procesador que decodifica y activar\u00e1n una determinada funci\u00f3n del dispositivo. En el reto y las actividades del mismo obtendremos estos c\u00f3digos. En ArduinoBlocks se han asignado los siguientes nombres a las teclas:</p> <p> <p> A08. Nombre teclas control remoto en Arduinoblocks</p> <p></p> <p>Bloques en Arduinoblocks <p>El sensor receptor de infrarrojos permite obtener la cadena de texto con el c\u00f3digo en formato hexadecimal correspondiente al tren de pulsos de IR generado al pulsar una determinada tecla. Si utilizamos mandos gen\u00e9ricos RC5 como el modelo de Keyestudio, podemos usar los bloques de la imagen siguiente para comparar los c\u00f3digos recibidos y as\u00ed identificar f\u00e1cilmente cada tecla.</p> <p> Sensores En 3DBot <p></p> <p>El valor devuelto por el bloque de recepci\u00f3n ser\u00e1 una cadena de texto con valor vac\u00edo en caso de no detectar ning\u00fan c\u00f3digo. Al devolver el bloque una cadena de texto debemos recordar que lo tenemos que almacenar en una variable de tipo texto.</p>"},{"location":"Imagina/actividades/#a08_1-tecla-ok-pulsada","title":"A08_1. Tecla OK pulsada","text":"<p>Vamos a realizar un programa en el que si pulsamos la tecla Ok del control remoto se nos encienda el diodo LED rojo. El programa lo vemos en la imagen siguiente:</p> <p> <p> A08_1. Tecla OK pulsada</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/actividades/#a08_2-codigo-de-la-tecla-pulsada","title":"A08_2. C\u00f3digo de la tecla pulsada","text":"<p>Vamos a realizar un programa que nos muestre por consola el c\u00f3digo hexadecimal correspondiente a cada una de las teclas pulsadas junto a un texto descriptivo indicador de la tecla pulsada en cada caso, es decir, que mantenga una estructura del tipo: El CODIGO se corresponde con la tecla TECLA pulsada.</p> <p> <p> A08_2. C\u00f3digo de la tecla pulsada</p> <p>Acceder al programa</p> <p></p> <p>Para facilitar la visualizaci\u00f3n se han dividido las teclas en grupos por funciones y dos de ellas se muestran con los bloques contraidos.</p> <p>En la imagen siguiente vemos el resultado:</p> <p> <p> A08_2. C\u00f3digo de la tecla pulsada</p> <p></p>"},{"location":"Imagina/amplia/","title":"Actividades de ampliaci\u00f3n","text":"<p>Se realizan una serie de actividades con material opcional que NO est\u00e1 incluido en el kit b\u00e1sico.</p> <p>Contamos con muchos accesorios opcionales para poder conectar al robot. Existen un par de opciones muy interesantes que son: una pantalla de texto y una matriz de LED de tipo I2C.</p> <p> <p> Conector I2C en la placa Imagina 3DBot</p> <p></p>"},{"location":"Imagina/amplia/#el-bus-i2c","title":"El bus I2C","text":"<p>Las siglas I2C corresponden en realidad a I\u00b2C que tiene su origen en las iniciales del ingl\u00e9s Inter-Integrated Circuit (IIC = I\u00b2C) y que siginifican Circuito Inter-Integrado y vamos a explicar un poco en que consiste este sistema de conexionado.</p> <p>El bus conocido por las siglas I2C, IIC o I\u00b2C, es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes.</p> <p>I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C.</p> <p>El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la imagen siguiente vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master.</p> <p> <p> Diagrama de conexi\u00f3n del bus I2C</p> <p></p> <p>Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n f\u00edsica, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores, o por software.</p> <p>En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario.</p> <p>El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el master prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente.</p> <p>El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en UART o SPI. En la imagen vemos un cronograma ejemplo del funcionamiento del sistema.</p> <p> <p> Cronograma de trabajo del bus I2C</p> <p></p> <p>El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia:</p> <ul> <li>Primero, el master genera la se\u00f1al de reloj del bus (SCL).</li> <li>Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo.</li> <li>El master direcciona a los slaves.</li> <li>El master indica si se va a leer o escribir.</li> <li>El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge).</li> <li>Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n.</li> <li>El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK.</li> <li>Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo.</li> </ul> <p>Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 (27) dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo.</p> <p>Existen, adem\u00e1s, concentradores o hubs que permiten conectar mas de un dispositivo a la vez.</p> <p> <p> Hub bus I2C</p> <p></p>"},{"location":"Imagina/amplia/#aam_1-pantalla-lcd1602","title":"AAm_1. Pantalla LCD1602","text":"<p>Una pantalla LCD (del ing\u00e9s, Liquid Cristal Display) de 2 l\u00edneas de 16 caracteres tiene el aspecto y la distribuci\u00f3n de pines que vemos en la imagen siguiente.</p> <p> <p> LCD 2x16</p> <p></p> <p>Es evidente que deber\u00edamos utilizar bastantes patillas de nuestra placa tipo UNO (es el formato que tiene la ESP32 STEAMakers) para su control. En la imagen siguiente se muestra el conexionado m\u00ednimo necesario en una pantalla de este tipo: 4 bits para datos y dos se\u00f1ales de control En (Enable) y Rs (Register select). La conexi\u00f3n RW la ponemos a GND. Adem\u00e1s se debe a\u00f1adir una resistencia ajustable o un potenci\u00f3metro para regular el contraste de la pantalla.</p> <p> <p> Conexionado m\u00ednimo LCD 2x16</p> <p></p> <p>Es preferible utilizar alguna de las que tienen el aspecto que vemos en la imagen siguiente:</p> <p> <p> LCD 2x16 con m\u00f3dulo I2C</p> <p></p> <p>En realidad el conjunto que vemos en la imagen anterior no es mas que una LCD 2x16 a la que se ha incorporado un m\u00f3dulo adaptador de LCD a I2C. Este modulo est\u00e1 especialmente dise\u00f1ado para poder soldarlo directamente a la LCD y convertirla as\u00ed en un dispositivo I2C que adem\u00e1s ya lleva incorporado el potenci\u00f3metro de ajuste de contraste en alguno de los casos.</p> <p>Este tipo de pantalla requiere cuatro cables para establecer las conexiones, dos cables SDA (datos) y SCL (reloj) para el bus de comunicaciones I2C y los dos cables de alimentaci\u00f3n VCC y GND.</p> <p>La direcci\u00f3n I2C por defecto de este tipo de m\u00f3dulos puede ser 0x3F o en otros casos 0x27, e incluso hay modelos en los que se puede cambiar. Para un correcto control es muy importante identificar correctamente la direcci\u00f3n I2C de nuestro modulo pues de otra forma nuestro programa no funcionar\u00e1 correctamente.</p> <p>Una LCD 1602 I2C es muy sencilla de controlar a partir de los bloques que nos proporciona ArduinoBlocks.</p> <p>En el bloque \u201cVisualizaci\u00f3n \u2192 Pantalla LCD\u201d encontramos la funci\u00f3n \u201cLCD iniciar\u201d, que sirve para indicar que vamos a utilizar la pantalla, y que debe colocarse dentro del bloque \u201cInicializar\u201d, y la funci\u00f3n \u201cLCD Imprimir\u201d, que debe ponerse dentro del bloque \u201cBucle\u201d. En la imagen siguiente vemos los bloques disponibles.</p> <p> <p> Bloques para trabajar con LCDs</p> <p></p> <p>En la siguiente figura se muestra el sistema de distribuci\u00f3n de filas y columnas.</p> <p> <p> Sistema de coordenadas en una LCD 1602</p> <p></p>"},{"location":"Imagina/amplia/#escanear-dispositivos-i2c","title":"Escanear dispositivos I2C","text":"<p>Si no conocemos la direcci\u00f3n especifica de nuestro m\u00f3dulo podemos utilizar un peque\u00f1o programa que llamaremos Escaner_I2C y que se encargar\u00e1 de identificar la direcci\u00f3n I2C y todos los dispositivos I2C conectados a nuestra placa. Debemos crear un proyecto para tener disponible el men\u00fa I2C que nos de acceso al bloque \"Escanear dispositivos I2C...\" tal y como vemos en la imagen siguiente:</p> <p> <p> Menu I2C</p> <p></p> <p>El programa Escaner_I2C nos permite ver en la Consola la direcci\u00f3n f\u00edsica de los dispositivos I2C conectados a la placa.</p> <p> <p> Programa Escaner_I2C</p> <p></p> <p>IMPORTANTE <p>En el caso de la placa ESP32 STEAMakers no ocurre como en otras tipo Arduino, que cuando conectamos la consola se efect\u00faa un reset autom\u00e1tico de la placa por lo que es muy posible que el programa de escaneo nos muestre una consola sin resultado alguno o en blanco. Simplemente, con la consola ya conectada, hacemos un reset f\u00edsico en la placa y el problema quedar\u00e1 solucionado.</p> <p>En la figura siguiente tenemos el resultado que se muestra con el programa anterior cargado, conectar la consola y hacer reset. En este caso vemos los cinco dispositivos conectados a trav\u00e9s de un hub y la placa TdR STEAM.</p> <p> <p> Consola para el programa Escaner_I2C con 5 dispositivos</p> <p></p> <p>Otra opci\u00f3n para hacer un esc\u00e1ner I2C que no necesita el reset es el programa que vemos en la figura siguiente y que lleva al bucle la orden de escaneo que se va a ejecutar cada 10 segundos, aunque este tiempo puede ser otro cualquiera.</p> <p> <p> Programa Escaner_I2C_bucle en el bucle con 5 dispositivos</p> <p></p> <p>En la figura siguiente vemos el resultado en la consola y como coincide con el anterior.</p> <p> <p> Consola para el programa Escaner_I2C_bucle en el bucle con 5 dispositivos</p> <p></p>"},{"location":"Imagina/amplia/#cambiar-la-direccion-fisica-del-dispositivo-i2c","title":"Cambiar la direcci\u00f3n f\u00edsica del dispositivo I2C","text":"<p>Esta tarea nos va a resultar especialmente \u00fatil si disponemos de LCDs I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varias de ellas en nuestro proyecto.</p> <ul> <li>LCD SIN micro interruptores</li> </ul> <p>La parte posterior de la LCD 1602 de Keyestudio tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en los tres grupos de agujeros enmarcados en rojo. Aunque en este caso no vienen nombrados los vamos a denominar A0, A1 y A2 de izquierda a derecha.</p> <p> <p> Pads configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C</p> <p></p> <p>La direcci\u00f3n por defecto de f\u00e1brica en este caso es la 0x27, pero se puede cambiar alterando la situaci\u00f3n de conexionado de estos agujeros entre si seg\u00fan la tabla siguiente:</p> <p> A2 A1 A0 Direcci\u00f3n 0 0 0 0x27 0 0 1 0x26 0 1 0 0x25 0 1 1 0x24 1 0 0 0x23 1 0 1 0x22 1 1 0 0x21 1 1 1 0x20 <p></p> <p>Para establecer los unos de la tabla anterior basta con cortocircuitar los dos pads correspondientes. En la imagen siguiente se ha establecido la direcci\u00f3n f\u00edsica como 0x26.</p> <p> <p> Direcci\u00f3n 0x26</p> <p></p> <ul> <li>LCD CON micro interruptores</li> </ul> <p>La parte posterior de la LCD 1602 de Keyestudio con micro interruptores para cambiar su direcci\u00f3n f\u00edsica tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en el recuadro azul donde est\u00e1n los microinterruptores que permiten cambiar el estado del bit y encima de los mismo est\u00e1 la informaci\u00f3n de la direcci\u00f3n f\u00edsica que se asigna a cada combinaci\u00f3n. La tabla es exactamente la misma que en el caso anterior.</p> <p> <p> Configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C con microinterruptores</p> <p></p>"},{"location":"Imagina/amplia/#definicion-de-simbolos-en-la-lcd","title":"Definici\u00f3n de s\u00edmbolos en la LCD","text":"<p>Dentro de los bloques del men\u00fa Visualizaci\u00f3n -&gt; Pantalla LCD est\u00e1 el de \"definir s\u00edmbolo\", que permite definir uno de los 8 s\u00edmbolos personalizables que puede almacenar el micro de la pantalla LCD. El s\u00edmbolo se define por un mapa de bits (unos y ceros indicando cada p\u00edxel del s\u00edmbolo). Los s\u00edmbolos tienen una resoluci\u00f3n de 5x8 p\u00edxeles (blanco o negro).</p> <p>En ArduinoBlocks disponemos de una herramienta que nos ayuda a definir nuestros propios s\u00edmbolos y podemos acceder a ella desde herramientas o haciendo clic derecho sobre el bloque, despleg\u00e1ndose en cualquier caso un editor muy sencillo de usar y que vemos con un ejemplo en la imagen en la siguiente:</p> <p> <p> Ejemplo de s\u00edmbolo creado con el editor</p> <p></p>"},{"location":"Imagina/amplia/#aam_1_1-mensajes","title":"AAm_1_1. Mensajes","text":"<p>Se trata de mostrar una determinada informaci\u00f3n en la pantalla consistente en varios textos en ambas filas que se ir\u00e1n alternando cada tres segundos.</p> <p> <p> AAm_1_1. Mensajes</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/amplia/#aam_1_2-distancia","title":"AAm_1_2. Distancia","text":"<p>Mostrar en una LCD la distancia en cent\u00edmetros a un objeto detectado por el sensor HC-SR04.</p> <p> <p> AAm_1_2. Distancia</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/amplia/#aam_2-matriz-de-led","title":"AAm_2. Matriz de LED","text":"<p>Una distribuci\u00f3n de 8x8 LEDs en forma de matriz permite crear una pantalla peque\u00f1a que tiene 64 LEDs con el aspecto de la Figura siguiente y se conecta al puerto de comunicaci\u00f3n I2C.</p> <p> <p> Aspecto de la matriz de 8x8</p> <p></p> <p>Este tipo de matrices son 'multiplexadas', por lo que para controlar 64 LED necesitas 16 pines y eso son muchos pines aunque hay chips de controladores como el MAX7219 que pueden controlar una matriz, pero a\u00fan as\u00ed hay mucho cableado que configurar y ocupan muchos pines. Para solucionar esto se utiliza un chip de control que tiene un reloj incorporado para multiplexar la pantalla. Adem\u00e1s del m\u00f3dulo utiliza una fuente de corriente constante que permite obtener un color uniforme y brillante de todos los diodos. El conjunto forma una matriz de 8x8 que se controla a trav\u00e9s de una interfaz I2C.</p> <p>Sus principales caracter\u00edsticas son:</p> <ul> <li>Matriz de LEDs de 8 filas y 8 columnas</li> <li>Direccionada por un chip HT16K33</li> <li>Conexi\u00f3n tipo I2C</li> <li>Tensi\u00f3n de alimentaci\u00f3n: 5V</li> <li>Frecuencia de trabajo: 400KHz</li> <li>Potencia de entrada: 2.5W</li> <li>Corriente de entrada: 500mA</li> </ul> <p>Tambi\u00e9n existen matrices que son direccionables, como la que vemos en la imagen siguiente:</p> <p> <p> Aspecto de la matriz de 8x8 direccionable</p> <p></p> <p>El dispositivo dispone de su propio men\u00fa de bloques y de un dise\u00f1ador de mapas de bits similar al visto para los s\u00edmbolos de la LCD que podemos apreciar en la figura siguiente:</p> <p> <p> Bloques para la matriz 8x8 y dise\u00f1ador</p> <p></p> <p>Como actividad vamos a crear dos mapas de bits de dos corazones de forma que parezca que es un coraz\u00f3n latiendo. Procedemos como vemos en la animaci\u00f3n siguiente:</p> <p> <p> Dise\u00f1o de un mapa de bits</p> <p></p> <p>La otra imagen puede tener el siguiente aspecto:</p> <p> <p> Dise\u00f1o de un mapa de bits</p> <p></p> <p>A continuaci\u00f3n vemos el programa:</p> <p> <p> AAm_2. Latidos</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/amplia/#aam_3-control-de-un-servomotor","title":"AAm_3. Control de un servomotor","text":""},{"location":"Imagina/amplia/#el-servo","title":"El servo","text":"<p>Un servomotor o abreviado servo es un motor especial que puede posicionar su eje en un \u00e1ngulo determinado y lo puede mantener en esta posici\u00f3n. Los servos est\u00e1ndar suelen girar 180\u00ba, pero es habitual encontrar servos que giran 90\u00ba y otros 360\u00ba, que son los conocidos como servos de rotaci\u00f3n continua. En el interior del mismo est\u00e1n ubicados tanto la electr\u00f3nica de control como los engranajes reductores que a su vez pueden llevar o no topes f\u00edsicos que marquen el \u00e1ngulo de giro. Para su funcionamiento s\u00f3lo necesitan ser alimentados (conexiones GND y VCC o 5V) y una se\u00f1al de control.</p> <p>Los servomotores son en realidad motores de corriente continua a los que se les ha a\u00f1adido una reductora, para que giren m\u00e1s despacio y con m\u00e1s fuerza, y un controlador electr\u00f3nico que permite hacer que gire un determinado \u00e1ngulo. Adem\u00e1s, el servo en todo momento sabe en qu\u00e9 posici\u00f3n est\u00e1, aunque se apague o reinicie. Esto significa que si a un servo que hemos movido a un determinado punto, lo hemos dejado sin alimentaci\u00f3n y al alimentarlo de nuevo le indicamos que gire 90\u00ba, no va a girar 90\u00ba sino que se va a dirigir a su posici\u00f3n de 90\u00ba que tiene memorizada internamente.</p> <p>En la figura siguiente vemos el interior de un servo esquematizado.</p> <p> <p> Interior de un servo 9g</p> <p></p> <p>Su aspecto real lo vemos en esta otra figura, donde tambi\u00e9n se aprecian las palas y torniller\u00eda que lo acompa\u00f1an.</p> <p> <p> Aspecto real servo 9g</p> <p></p> <p>Veamos su principio b\u00e1sico de funcionamiento: La electr\u00f3nica de control del servomotor tiene un circuito de referencia incorporado que emite la se\u00f1al de referencia, que es un ciclo de 20 ms con un ancho de pulso de 1,5 ms. Se compara la tensi\u00f3n de control recibida con la de referencia y se genera una diferencia de tensi\u00f3n. El circuito de control en la placa decidir\u00e1 la direcci\u00f3n de rotaci\u00f3n en consecuencia y accionar\u00e1 el motor. El sistema de engranajes o reductora convierten el giro del motor en un par de fuerza a trav\u00e9s del eje. El sensor detecta que se ha alcanzado la posici\u00f3n enviada de acuerdo con la se\u00f1al de retroalimentaci\u00f3n. Cuando la diferencia de tensi\u00f3n existe el motor gira y cuando la diferencia se reduce a cero, el motor se detiene. Normalmente, el \u00e1ngulo de rotaci\u00f3n es de 0 a 180 grados.</p> <p>El servomotor viene con un conector hembra de tres pines para tres cables de conexi\u00f3n, que se distinguen por los colores marr\u00f3n, rojo y naranja (diferentes marcas pueden tener diferentes colores).</p> <p>El \u00e1ngulo de rotaci\u00f3n del servomotor se controla regulando el ciclo de trabajo de la se\u00f1al PWM cuyo est\u00e1ndar es de 20 ms (50 Hz).</p> <p>Hay que tener mucho cuidado de posicionar el conector de los servos en los tres pines macho de la shield en el orden correcto (el conector es reversible) o seguramente romperemos algo de manera irremediable.</p> <p>Existe un tipo especial de servomotor que permite la rotaci\u00f3n continua. En algunos casos se trata de servomotores \u201ctrucados\u201d de forma que se modifican para permitir la rotaci\u00f3n continua quitando los topes mec\u00e1nicos y se sustituye el potenci\u00f3metro por un divisor de tensi\u00f3n con dos resistencia iguales (en algunos casos no se ponen resistencias y se bloquea el potenci\u00f3metro para que no gire dej\u00e1ndolo justo en su punto central). Este tipo de modificaci\u00f3n la podemos realizar nosotros (en la web existen multitud de tutoriales) o tambi\u00e9n podemos comprar un servomotor de rotaci\u00f3n continua listo para funcionar sin tener que hacer ning\u00fan tipo de bricolaje.</p> <p>En el apartado de bloques de programaci\u00f3n, se encuentra en \"Motor / Servo\" y en la figura siguiente vemos los bloques disponibles.</p> <p> <p> Bloques para servos</p> <p></p> <p>Para controlar el servomotor, indicamos los grados de rotaci\u00f3n (\u00c1ngulo de giro) que queremos y el tiempo de retardo, o tiempo que tarda en ir de una posici\u00f3n a otra.</p> <p>El control de un servomotor de rotaci\u00f3n continua se realiza de igual manera, pero su reacci\u00f3n es diferente.</p> <p>Los bloques Servo-Oscilador nos permiten de una forma sencilla hacer que el servo repita una secuencia de movimientos u oscilaciones de forma indefinida. Un ejemplo t\u00edpico puede ser el que vemos en la figura siguiente, donde el servo oscila entre 0 y 90\u00ba en periodos de dos segundos.</p> <p> <p> Oscilaci\u00f3n con servo</p> <p></p> <p>El bloque Servo-I2C (PCA9685) es simplemente un bloque para manejar la tarjeta controladora para 16 servos PCA9685 utilizando el bus I2C.</p>"},{"location":"Imagina/amplia/#posicionar-el-servo","title":"Posicionar el servo","text":"<p>Antes de fijar con el tornillo la pala debemos averiguar cual es su posici\u00f3n de 0\u00ba o inicial. Para ello vamos a crear el programa Posicionar_servo que vemos en la figura siguiente o que podemos importar del enlace.</p> <p> <p> Posicionar_servo</p> <p>Acceder al programa</p> <p></p> <p>Ejecutamos el programa que hemos cargado en la placa, y lo tenemos que parar en el momento que el servo vuelve a la posici\u00f3n inicial (hace un giro repentino de 180\u00ba tras un tiempo de espera mas largo). En ese momento, quitamos el soporte tipo aspa vigilando de que no se modifique la posici\u00f3n del servo. Sin que el servomotor se haya movido, montamos el soporte en su lugar y damos por concluida la tarea.</p>"},{"location":"Imagina/amplia/#listas","title":"Listas","text":"<p>Las listas de datos nos permiten almacenar un listado de valores y acceder a ellos por su posici\u00f3n o \u00edndice en la lista. Las listas pueden ser de tipo num\u00e9ricas o de texto, como vemos en la imagen siguiente:</p> <p> <p> Tipos de listas en Arduinoblocks</p> <p></p> <p>En la animaci\u00f3n siguiente vemos el proceso de creaci\u00f3n de una lista num\u00e9rica y los elementos que se crean con la misma.</p> <p> <p> Creaci\u00f3n de listas en Arduinoblocks</p> <p></p> <p>Los bloques que se crean nos permiten asignarle valores, saber el n\u00famero de elementos que tiene una lista, obtener el valor de una posici\u00f3n de la lista o cambiar el valor de un elemento de la lista.</p> <p>De forma muy similar se pueden crear y trabajar con lista de textos.</p> <p>Vamos a realizar un programa que vamos a dividir en varias partes:</p> <ul> <li>Parte 1: Mover el servo a partir de una lista de posiciones creada previamente.</li> <li>Parte 2: Mover de forma autom\u00e1tica el servo entre 0 y 180 grados con retardos de un segundo.</li> </ul> <p>Crearemos una funci\u00f3n para cada apartado y ser\u00e1n llamadas dependiendo de si el pulsador est\u00e1 accionado o no. La soluci\u00f3n la tenemos disponible en el programa que vemos en la imagen siguiente:</p> <p> <p> Listas</p> <p>Acceder al programa</p> <p></p>"},{"location":"Imagina/avanzadas_imagina/","title":"Actividades avanzadas con la placa Imagina 3DBot","text":"<p>En esta secci\u00f3n realizaremos ejercicios con elementos IoT, interactuar con Telegram, Bluetooth, mando Nunchuk. Todo ello basado en:</p> <ul> <li>Manual 3DBot de Innova Didactic</li> <li>Tutorial de Pedro Ruiz Ejemplos 3DBot + ESP32 STEAMakers</li> </ul>"},{"location":"Imagina/avanzadas_imagina/#telegram","title":"Telegram","text":"<p>Es una aplicaci\u00f3n de mensajer\u00eda instant\u00e1nea que fue lanzada por los hermanos Nikol\u00e1i y P\u00e1vel D\u00farov en el a\u00f1o 2013 como una alternativa a WhatsApp y que actualmente cuenta con mas de 800 millones de usuarios.</p> <p>Telegram sirve principalmente chatear con nuestros contactos a trav\u00e9s de mensaje de texto, audio, llamadas, videollamadas\u2026 y compartir fotos, videos, archivos, stickers, tu ubicaci\u00f3n, etc.</p> <p>Telegram permite crear bots (usuarios no humanos), mensajes autom\u00e1ticos, chats secretos y organizar por grupos y canales de difusi\u00f3n. Se puede instalar en dispositivos m\u00f3viles o como una aplicaci\u00f3n de escritorio o utilizar o bien utilizarlo en un navegador web.</p>"},{"location":"Imagina/avanzadas_imagina/#crear-un-bot-en-telegram","title":"Crear un bot en Telegram","text":"<p>Un bot, o chatbot, es una aplicaci\u00f3n capaz interactuar en una conversaci\u00f3n real con un usuario de manera bastante natural.</p> <p>Estamos habituados a que se usen los bots automatizando servicios al cliente y son utilizados para responder rapidamente a preguntas, atender consultas 24 horas 7 dias a la semana y pueden recopilar comentarios de los clientes tras su servicio. En nuestro caso vamos a usarlos para intercambiar informaci\u00f3n entre nuestra placa y un dispositivo m\u00f3vil, por lo que necesitamos crear un bot que permita realizar estas tareas.</p> <p>La forma mas r\u00e1pida y sencilla de crear un bot en Telegram es utilizando el \"Padrino de los bots\" o BotFather, que es un bot oficial de Telegram que, como indica en su informaci\u00f3n es el bot que los domina a todos.</p> <p> <p> BotFather info</p> <p></p> <p>Este bot lo puedes usar para crear nuevas cuentas de bot y gestionar tus bots existentes.</p> <p>Cuando invocamos BotFather este nos devuelve un mensaje como el que vemos a continuaci\u00f3n:</p> <p> <p> @BotFather</p> <p></p> <p>El propio bot nos explica que con el mismo podemos crear y manejar bots de Telegram, nos muestra un enlace al manual de la API del Bot y nos lista los comandos de control que tenemos disponibles.</p> <p>Observamos que todos los comandos comienzan con '/' y cuando tecleamos esta en el chat autom\u00e1ticamente BotFather nos devuelve un listado con todos ellos para que podamos seleccionar el que nos interesa.</p> <p>Vamos a comenzar por crear un nuevo Bot, para lo que necesitamos chatear con BotFather tecleando el comando de creaci\u00f3n de un nuevo bot, <code>/newbot</code> en nuestro Telegram y a continuaci\u00f3n nos indicar\u00e1 que tecleemos el nombre del Bot, en este caso ser\u00e1 <code>3DBot</code>. Si damos un nombre v\u00e1lido nos pedir\u00e1 que le pongamos un nombre de usuario al Bot, en nuestro caso ser\u00e1 <code>Imagina_3D_bot</code>. El nombre debe terminar siempre con la palabra bot o _bot.</p> <p> <p> Creaci\u00f3n del bot 3DBot con BotFather</p> <p></p> <p>Ya tenemos creado el nuevo bot con un usuario y entre otras cosas nos da el Token que necesitamos para conectar con la API de Telegram.</p> <p> <p> Bot creeado</p> <p></p> <p>Si una vez creado el bot queremos completar su informaci\u00f3n o modificarlo, la forma mas sencilla es a trav\u00e9s del comando <code>/mybots</code> y escoger el bot a modificar y seguir las opciones que nos muestra el men\u00fa de botones.</p> <p> <p> Acceso a mis bots y men\u00fa de botones</p> <p></p> <p>Cuando escogemos el bot se nos presenta el siguiente men\u00fa:</p> <p> <p> Opciones de configuraci\u00f3n del bot</p> <p></p> <p>En la edici\u00f3n del Bot podemos observar como se han editado algunas de las opciones:</p> <p> <p> Opciones de configuraci\u00f3n del bot editadas</p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#bloques-arduinoblocks","title":"Bloques Arduinoblocks","text":"<p>Para poder trabajar con Telegram arduinoblocks nos ofrece una serie de bloques y tenemos que utilizarlos convenientemente para poder interactuar desde Telegram con nuestras placas.</p> <ul> <li>Iniciar Telegram Bot: permite iniciar el sistema Telegram en la ESP32, debemos indicar el Token obtenido para la API al crear el bot con @botfather:</li> </ul> <p> <p> Iniciar Telegram Bot</p> <p></p> <ul> <li> <p>Enviar un mensaje: permite enviar mensajes a cualquier chat de telegram directamente.</p> <ul> <li>Chat-ID: puede ser el ID de una conversaci\u00f3n privada o un usuario en concreto, de un grupo o de un canal.</li> <li>Texto del mensaje: el texto con el mensaje que se quiere enviar</li> <li>Formato: Se pueden indicar tres tipos de formato para aplicar estilos al mensaje (negrita, t\u00edtulos, etc.). Formato: Markdown, MarkdownV2 o HTML</li> </ul> </li> </ul> <p> <p> Enviar un mensaje</p> <p></p> <ul> <li>Evento de cuando se recibe un nuevo mensaje desde Telegram:<ul> <li>Dentro de este bloque procesaremos el mensaje recibido, pudiendo acceder al texto del mensaje, al remitente (nombre) y al Chat-ID de donde procede el mensaje.</li> <li>Aqu\u00ed responderemos o actuaremos seg\u00fan el mensaje que nos llegue.</li> </ul> </li> </ul> <p> <p> Evento de cuando se recibe un nuevo mensaje desde Telegram</p> <p></p> <ul> <li> <p>Mensaje recibido: Este bloque s\u00f3lo tiene sentido usarlo dentro del evento de \u201cnuevo mensaje recibido\u201d, si se usa fuera de \u00e9l su contenido estar\u00e1 vac\u00edo.</p> <ul> <li>Texto: texto del mensaje recibido</li> <li>Chat ID: ID del chat de donde procede el mensaje. Muy \u00fatil para responder a ese mismo chat (pueden llegar mensajes de distintos chats, grupos, etc. por lo que de esta forma identificamos el origen y nos sirve para responder al chat correcto)</li> <li>Remitente: El nombre del usuario remitente del mensaje.</li> </ul> </li> </ul> <p>Nuestros programas van a necesitar un bloque inicializar en el que conectemos la placa a una red WiFi y suminstremos el token facilitado por el Bot.</p> <p> <p> Bloque inicializar</p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#id-del-chat","title":"ID del chat","text":"<p>Si queremos que nuestro Bot env\u00ede mensajes a un chat vamos a necesitar averiguar el ID o n\u00famero que identifica al chat en cuesti\u00f3n. Tenemos dos ID que nos interesan:</p> <ul> <li>ID de chat privado. Lo necesitaremos si queremos que el Bot env\u00ede mensajes a nuestro usuario de Telegram. Iniciamos Telegram y localizamos un bot llamado @myidbot, lo iniciamos y en el men\u00fa nos indica las dos ordenes que soporta.</li> </ul> <p> <p> ID de chat privado</p> <p></p> <p>El mensaje \u00bfQu\u00e9 puede hacer este bot? traducido y original es:</p> <p> <p> ID de chat privado</p> <p></p> <p>La respuesta a la orden <code>/getid</code> ser\u00e1:</p> <p> <p> ID de chat privado</p> <p></p> <p>Si ejecutamos la orden <code>/getgroupid</code> nos va a devolver un mensaje indicandonos que para obtener el ID de un grupo o canal debemos seguir uno de los pasos que indica, y que vemos a continuaci\u00f3n.</p> <p> <p> ID de chat privado</p> <p></p> <ul> <li>ID de un grupo. Debemos a\u00f1adir al grupo a @myidbot, hacerlo administrador y despu\u00e9s preguntar por <code>/getgroupid</code>. Seleccionamos nuestro grupo de pruebas y procedemos de la siguiente forma:</li> </ul> <p> <p> ID de grupo</p> <p></p> <p>Las ordenes disponibles ahora son:</p> <p> <p> Ordenes disponibles en ID de grupo</p> <p></p> <p>Una vez ejecutadas obtenemos los resultados correspondientes, en el primer caso obtenemos el mismo ID que anteriormente y en el segundo un valor negativo que es el ID del grupo.</p> <p> <p> Resultado ordenes en ID de grupo</p> <p></p> <p>Una vez conocidos los ID de usuario y de grupo podemos eliminar al Bot @myidbot del grupo.</p>"},{"location":"Imagina/avanzadas_imagina/#telegram-actividad-avanzada-1","title":"Telegram: Actividad avanzada 1","text":"<p>En esta actividad vamos a recibir en nuestro Bot de telegram la temperatura a la que est\u00e1 la placa y la mostraremos tambi\u00e9n en el monitor serie del ordenador.</p> <p> <p> Actividad avanzada con Telegram 1</p> <p>Acceder al programa</p> <p></p> <p>Para poder probar el Bot creado debemos meter al usuario en un grupo. En mi caso voy a tener un grupo con solo dos usuarios, yo mismo y el del Bot.</p> <p> <p> Grupo de pruebas de 3DBot</p> <p></p> <p>A continuaci\u00f3n vemos las respuesta que nos da la placa a las ordenes tecleadas y como responde la consola de arduinoblocks.</p> <p> <p> </p> <p> Pruebas de 3DBot</p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#telegram-actividad-avanzada-2","title":"Telegram: Actividad avanzada 2","text":"<p>Se trata de realizar un programa asociado a un bot de Telegram que sea capaz de realizar las siguientes acciones sobre la placa Imagina 3DBot:</p> <ul> <li>al teclear <code>/ayuda</code> o <code>/help</code> nos responde con todas las \u00f3rdenes disponibles</li> <li>al teclear <code>/led=rojo</code>se encender\u00e1 el LED rojo de la placa</li> <li>al teclear <code>/led=verde</code>se encender\u00e1 el LED verde de la placa</li> <li>al teclear <code>/led=amarillo</code>se encender\u00e1 el LED amarillo de la placa</li> <li>al teclear <code>/led=negro</code>se apagar\u00e1n los tres LEDs.</li> <li>al teclear <code>/tpambiente</code> nos mostrar\u00e1 la temperatura ambiente que detecta la NTC</li> <li>al teclear <code>/tpplaca</code> nos mostrar\u00e1 la temperatura del ESP32</li> <li>al teclear <code>/ilumina</code> nos mostrar\u00e1 el nivel de iluminaci\u00f3n de la LDR</li> </ul> <p>El programa llevar\u00e1 los mismos bloques y configuraci\u00f3n que en la actividad anterior en lo referente a <code>Inicializar</code> y el bloque de Telegram del evento <code>Nuevo mensaje recibido</code> lo analizamos por partes dado que tiene un tama\u00f1o que en una sola imagen no se aprecia adecuadamente.</p> <ul> <li> <p>al teclear <code>/ayuda</code> o <code>/help</code>. Simplemente en el bloque <code>si ... hacer ... sino</code> preguntamos si se ha recibido alguno de los dos mensajes y en caso afirmativo se envia el mensaje:</p> <p>/ayuda o /help: ordenes disponibles; /led=rojo: activa LED rojo; /led=verde: activa LED verde; /led=amarillo: activa LED amarillo; /tpambiente: temperatura NTC; /tpplaca: temperatura ESP32; /ilumina: nivel de iluminacion</p> </li> </ul> <p> <p> al teclear <code>/ayuda</code> o <code>/help</code></p> <p></p> <ul> <li>al teclear <code>/led=rojo</code>, <code>/led=verde</code>, <code>/led=amarillo</code> o <code>/led=negro</code>. Esta parte merece especial explicaci\u00f3n y la indicaci\u00f3n de que est\u00e1 tomada del tutorial de Pedro Ruiz Retos demo ESP32 Steamakers + TDR-Steam + Arduinoblocks (IoT), donde se realiza la \"elegante\" t\u00e9cnica de dividir el texto para quedarse con la parte que interesa.</li> </ul> <p> <p> al teclear <code>/led=rojo</code>, <code>/led=verde</code>, <code>/led=amarillo</code> o <code>/led=negro</code></p> <p></p> <ul> <li>al teclear <code>/tpambiente</code>, <code>/tpplaca</code> o <code>/ilumina</code>. Se muestran los valores del resto de variables y se envian los mensajes correspondientes. La opci\u00f3n <code>... sino</code> del primer condicional se ejecutar\u00e1 si no enviamos una consulta v\u00e1lida.</li> </ul> <p> <p> al teclear <code>/tpambiente</code>, <code>/tpplaca</code> o <code>/ilumina</code> Acceder al programa</p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#subir-datos-a-internet","title":"Subir datos a Internet","text":"<p>En esta actividad vamos a conectar la placa ESP32 STEAMakers a una red WiFi para subir a Internet datos de la propia placa y de la shield Imagina 3DBot. Los datos los enviamos a ThingSpeak, una plataforma que, entre muchas otras funcionalidades, nos hace gr\u00e1ficas de los datos que va recibiendo. Recuerda que ThingSpeak, si tienes una cuenta gratuita, te deja subir datos cada 15 segundos.</p>"},{"location":"Imagina/avanzadas_imagina/#thingspeak","title":"ThingSpeak","text":"<p>Lo primero que vamos a hacer es conectar la placa a la red WiFi. Para ello tenemos los bloques en el apartado \u201cComunicaciones \u2192 WiFi / IoT\u201d. Los bloques de MQTT tambi\u00e9n se encuentran en este mismo apartado, dentro de \u201cMQTT Client\u201d.</p> <p> <p> Bloques de conexi\u00f3n y configuraci\u00f3n</p> <p></p> <p>Una vez que tengamos la placa conectada a la red WiFi vamos a crear nuestro canal para enviar datos a Thingspeak.</p> <p>Para crear el canal debes seguir los siguientes pasos (despu\u00e9s de crear una cuenta):</p> <p> <p> Nuevo canal Thingspeak</p> <p></p> <p>Una vez dentro escribe el nombre del canal, una descripci\u00f3n (opcional), los campos que creas necesarios y el resto de informaci\u00f3n relativa al canal.</p> <p> <p> Campos canal Thingspeak</p> <p></p> <p>Si nos desplazamos al final en esa p\u00e1gina veremos el bot\u00f3n para guardar el canal:</p> <p> <p> Salvar canal Thingspeak</p> <p></p> <p>Con estos dos pasos ya tenemos creado el canal que por defecto se crea con visualizaci\u00f3n privada (solamente podemos verlo nosotros).</p> <p> <p> Canal Thingspeak</p> <p></p> <p>Si queremos cambiar la visualizaci\u00f3n lo hacemos en la pesta\u00f1a 'Sharing'. Ahora hemos de crear un dispositivo MQTT para el canal:</p> <p> <p> Dispositivo MQTT canal Thingspeak</p> <p></p> <p>Una vez pulsado el bot\u00f3n 'Add device' nos aparecen unas credenciales en la pantalla. Estas credenciales son necesarias para el bloque Iniciar de MQTT. An\u00f3talas o desc\u00e1rgalas y guardalas en lugar seguro, las necesitar\u00e1s m\u00e1s adelante.</p> <p> <p> Inicializaciones Arduinoblocks</p> <p></p> <p>El servidor MQTT de ThingSpeak se configura con:</p> <ul> <li>Direcci\u00f3n (Broker): mqtt3.thingspeak.com</li> <li>Puerto: 1883</li> </ul>"},{"location":"Imagina/avanzadas_imagina/#iot-actividad-avanzanda","title":"IoT: Actividad avanzanda","text":"<p>El programa para enviar datos lo ejecutamos cada 16 segundos por la limitaci\u00f3n de tratarse de un canal gratuito.</p> <p> <p> IoT_AAv1_Imagina. Programa Acceder al programa</p> <p></p> <p>Transcurridos unos minutos el estado del canal es el siguiente:</p> <p> <p> IoT_AAv1_Imagina. Resultados</p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#bluetooth","title":"Bluetooth","text":"<p>Los m\u00f3dulos Bluetooth permiten crear conexi\u00f3n inal\u00e1mbrica serie punto a punto de forma que la forma de trabajar es muy similar a la comunicaci\u00f3n serie por cable. A continuaci\u00f3n vemos lo b\u00e1sico de los m\u00f3dulos m\u00e1s comunes.</p>"},{"location":"Imagina/avanzadas_imagina/#introduccion","title":"Introducci\u00f3n","text":"<p>Bluetooth es una especificaci\u00f3n industrial para Redes Inal\u00e1mbricas de \u00c1rea Personal (WPAN) que posibilita la transmisi\u00f3n de voz y datos entre diferentes dispositivos mediante un enlace por radiofrecuencia en la banda ISM de los 2.4 a 2.485 GHz. Los principales objetivos que se pretenden conseguir con esta norma son:</p> <ul> <li>Facilitar las comunicaciones entre equipos m\u00f3viles.</li> <li>Eliminar los cables y conectores entre estos.</li> <li>Ofrecer la posibilidad de crear peque\u00f1as redes inal\u00e1mbricas y facilitar la sincronizaci\u00f3n de datos entre equipos personales.</li> </ul> <p>Se denomina Bluetooth al protocolo de comunicaciones dise\u00f1ado especialmente para dispositivos de bajo consumo, que requieren corto alcance de emisi\u00f3n y basados en transceptores (dispositivos que cuentan con transmisor y receptor compartiendo parte de la circuiteria) de bajo costo.</p> <p>El hardware que compone el dispositivo Bluetooth est\u00e1 compuesto por dos partes:</p> <ul> <li>un dispositivo de radio, encargado de modular y transmitir la se\u00f1al.</li> <li>un controlador digital, compuesto por una CPU, un procesador de se\u00f1ales digitales (DSP \u2013 Digital Signal Processor) llamado Link Controller (o controlador de Enlace) y de las interfaces con el dispositivo anfitri\u00f3n.</li> </ul> <p>Su logotipo lo vemos en la figura siguiente:</p> <p> <p> Logotipo Bluetooth con texto y sin texto</p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#bluetooth-v2","title":"Bluetooth V2","text":"<p>Existe un procedimiento definido que se llama Pairing (o emparejamiento) que vincula a dos dispositivos Bluetooth. Cuando vinculamos dos dispositivos Bluetooth, se inicia un proceso en el que ellos se identifican por nombre y direcci\u00f3n interna y se solicitan la clave PIN para autorizar la conexi\u00f3n.</p> <p>Si el emparejamiento se realiza con \u00e9xito, ambos nodos suelen guardar la identificaci\u00f3n del otro y cuando se encuentran cerca se vuelven a vincular sin necesidad de intervenci\u00f3n manual.</p> <p>Para manejar los m\u00f3dulos Bluetooth se utilizan los comandos Hayes o AT, de los que se puede encontrar informaci\u00f3n en este enlace y a continuaci\u00f3n damos algunos b\u00e1sicos:</p> <ul> <li>AT+VERSION: Versi\u00f3n del Firmware.</li> <li>AT+NAMEXXX: Para establecer el nombre que queremos presentar cuando otro dispositivo nos busque.</li> <li>AT+PINXXXX: permite establecer el n\u00famero de identificaci\u00f3n personal, que se requerir\u00e1 para establecer la vinculaci\u00f3n.</li> <li> <p>AT+BAUDX: Permite fijar la velocidad de comunicaci\u00f3n entre el modulo y la consola seg\u00fan los siguientes pares:</p> <p>1 -&gt; 1200 bps | -5 -&gt; 19200 bps</p> <p>2 -&gt; 2400 bps | -6 -&gt; 38400 bps</p> <p>3 -&gt; 4800 bps | -7 -&gt; 57600 bps</p> <p>4 -&gt; 9600 bps | -8 -&gt; 115200 bps</p> </li> </ul> <p>La velocidad por defecto es la de 9600 bps.</p> <p>Los m\u00f3dulos mas conocidos son el HC-05 y HC-06 que son Bluetooth V2 y cuyo aspecto podemos ver en la figura siguiente:</p> <p> <p> M\u00f3dulos HC-05 y HC-06</p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#bt-40-o-low-energy-ble","title":"BT 4.0 o Low Energy (BLE)","text":"<p>B\u00e1sicamente se trata de un nuevo protocolo dise\u00f1ado para reducir en todo lo posible el gran consumo de energ\u00eda de sus predecesores. Generalmente se le conoce como BLE (iniciales de Bluetooth Low Energy) o Bluetooth LE o tambi\u00e9n como Bluetooth Smart y tienen un consumo t\u00edpico que podemos cifrar entre los 10 y 15 mA. Otra de sus principales novedades radica en que este m\u00f3dulo si es utilizables con dispositivos iOS.</p> <p>El BLE es un subconjunto del est\u00e1ndar Bluetooth v4.0 que dispone de una pila de protocolos en referencia a la capa OSI (en ingl\u00e9s, Open Systems Interconnection) completamente nueva y orientada a conexiones sencillas en aplicaciones de muy baja potencia que suelen funcionar con pilas o bater\u00edas.</p> <p>La pila de protocolos para Bluetooth Low Energy sigue la estructura definida en la figura siguiente.</p> <p> <p> Pila de protocolos para BLE</p> <p></p> <p>El controlador aloja las capas inferiores de la pila del protocolo y tambi\u00e9n la radio. El Hots contiene las capas superiores de la pila de protocolos. Por encima de ambas estar\u00eda la aplicaci\u00f3n de usuario que es la que interact\u00faa con la pila de protocolos. La ventaja es que todas estas capas se pueden implementar en un solo chip o dividir en varios y conectarlos a trav\u00e9s de una capa de comunicaciones como UART, USB o SPI.</p> <ul> <li> <p>El controlador contiene las capas: Interfaz de controlador de host (HCI), Capa de enlace (LL) y Capa f\u00edsica (PHY)</p> <ul> <li>En la capa f\u00edsica (physical layer) se implementa toda la circuiteria de comunicaciones. La tecnolog\u00eda BLE puede usar hasta 40 canales de 2MHz en la banda ISM. El est\u00e1ndar emplea la t\u00e9cnica \u201cfrequency hopping\u201d o \u201csaltos en frecuencia\u201d, siguiendo una secuencia de saltos pseudo-aleatorios entre los canales frecuenciales mencionados que ofrece un alto grado de robustez frente a interferencias.</li> <li>La capa de enlace (link layer), se encarga de gestionar caracter\u00edsticas como los requerimientos temporales del est\u00e1ndar, chequeo de mensajes y reenv\u00edo de mensajes err\u00f3neos recibidos, gesti\u00f3n, filtrado de direcciones etc. Adem\u00e1s ofrece la definici\u00f3n de roles (Advertiser, Scanner, Master and Slave) que permiten identificar de forma l\u00f3gica el rol de cada dispositivo en el proceso de coElmunicaci\u00f3n. El nivel LL es del mismo modo responsable de procesos de control como el cambio de par\u00e1metros de la conexi\u00f3n o la encriptaci\u00f3n.</li> <li>el Host Controller o HCI es un protocolo est\u00e1ndar que permite que la comunicaci\u00f3n entre un host y un controlador se lleve a cabo a trav\u00e9s de un interfaz serie. A modo de ejemplo, en la mayor\u00eda de smartphones u ordenadores el host y la aplicaci\u00f3n corren en la CPU principal mientras que el controlador est\u00e1 situado en hardware espec\u00edfico y separado, conectado mediante UART o USB. El est\u00e1ndar Bluetooth define HCI como el conjunto de comandos y eventos para la interacci\u00f3n de ambas partes (host y controlador).</li> </ul> </li> <li> <p>El host contiene las siguientes capas: Perfil de acceso gen\u00e9rico (GAP), Perfil de atributo gen\u00e9rico (GATT), Protocolo de adaptaci\u00f3n y control de enlace l\u00f3gico (L2CAP), Protocolo de atributos (ATT), Gerente de seguridad (SM) y la Interfaz de controlador de host (HCI).</p> <ul> <li>La capa L2CAP (Logic Link Control and Adaptation Protocol), se responsabiliza de dos tareas fundamentales en un proceso de comunicaci\u00f3n. En primer lugar, el proceso de multiplexaci\u00f3n, es decir, la capacidad de dar formato a mensajes provenientes de las capas OSI superiores y encapsularlos en paquetes est\u00e1ndar BLE as\u00ed como el proceso inveM\u00f3dulrso.</li> <li>Para BLE, la capa L2CAP es la encargada de dar acceso y soporte a los dos protocolos fundamentales. Por un lado, ATT (Attribute Protocol), un protocolo basado en atributos presentados por dispositivo, con arquitectura cliente-servidor, que permite el intercambio de informaci\u00f3n. Por otro lado, SMP (Security Manager Protocol), protocolo que proporciona un framework para generar y distribuir claves de seguridad entre dos dispositivos.</li> <li>En el nivel m\u00e1s alto de la capa de protocolos, encontraremos de forma paralela las capas GAP y GATT. Esta primera, GAP (Generic Acces Profile), permite que un dispositivo sea visible hacia el resto de dispositivos y adem\u00e1s determina como puede interactuar un dispositivo entre otro. Establece distintas normas y conceptos para estandarizar las operaciones de m\u00e1s bajo nivel como:</li> </ul> </li> </ul> <ul> <li>Roles de interacci\u00f3n</li> <li>Modos de operaci\u00f3n y transici\u00f3n entre ellos</li> <li>Procedimientos para establecimiento de comunicaci\u00f3n</li> <li>Modos de seguridad y procedimientos</li> </ul> <ul> <li>Al otro lado, GATT (Generic Attribute Profile), que define como dos dispositivos BLE transfieren informaci\u00f3n. Este proceso tiene lugar cuando dos dispositivos han superado la fase de establecimiento de comunicaci\u00f3n (controlada por GAP) y comienza la transferencia de informaci\u00f3n pudiendo ser de forma bidireccional.</li> </ul> <p>En Arduinoblocks y en el caso del microcontrolador ESP32 con bluetooth integrado, simplemente debemos indicar el nombre del dispositivo Bluetooth para iniciar la comunicaci\u00f3n:</p> <p> <p> Bloque para inicializar BLE en ESP32</p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#aplicaciones-bluetooth","title":"Aplicaciones Bluetooth","text":"<p>Antes de usar cualquier aplicaci\u00f3n debemos emparejar el BLE de la ESP32 con nuestro m\u00f3vil.</p> <p>Existen muchas aplicaciones capaces de actuar como apps que permiten transmitir datos entre dispositivos Bluetooth. Vamos a usar de Google Play Store las siguientes:</p> <ul> <li>Bluetooth Terminal Qwerty, una apk con una interface muy simple y f\u00e1cil de configurar, basta conectarse con el dispositivo emparejado y comenzar a enviar comandos.</li> </ul> <p> <p> Bluetooth Terminal Qwerty</p> <p></p> <ul> <li>Arduino Bluetooth Controller es una aplicaci\u00f3n que le permite controlar su placa arduino (y placas similares) a trav\u00e9s de Bluetooth.</li> </ul> <p> <p> Logo Arduino Bluetooth Controller</p> <p></p> <p>Al lanzar la aplicaci\u00f3n se muestra una imagen y tras unos instantes aparece el men\u00fa gr\u00e1fico de la aplicaci\u00f3n. En la parte superior derecha tenemos el icono para conectar a un dispositivo.</p> <p> <p> Arduino Bluetooth Controller</p> <p></p> <p>En la imagen siguiente vemos el modo terminal de la aplicaci\u00f3n.</p> <p> <p> Modo terminal de Arduino Bluetooth Controller</p> <p></p> <ul> <li>Arduino Bluetooth Control tambi\u00e9n es una aplicaci\u00f3n que le permite controlar su placa arduino (y placas similares) a trav\u00e9s de Bluetooth</li> </ul> <p> <p> Logo Arduino Bluetooth Control</p> <p></p> <p>Se lanza la app, se escoge dispositivo y selecciona el modo terminal para estar en una situaci\u00f3n parecida a la de las otras aplicaciones.</p> <p> <p> Arduino Bluetooth Control</p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#bt-actividad-avanzada-1","title":"BT: Actividad avanzada 1","text":"<p>Vamos a crear un sencillo programa que nos muestre en la consola el caracter enviado desde una aplicaci\u00f3n en un m\u00f3vil.</p> <p> <p> Bluetooth: Actividad avanzada 1 Acceder al programa</p> <p></p> <p>Cargamos el programa en la placa, lanzamos la consola y emitimos comandos de una o varias letras desde alguna app del m\u00f3vil con la conexi\u00f3n con '3dbot' realizada. El nombre '3dbot' se ha establecido en el bloque inicializar y permite la conexi\u00f3n con el BLE de la ESP32.</p> <p>Vamos a obtener una serie de n\u00fameros que se corresponden con los valores decimales de los caracteres ASCII imprimibles.</p> <p> <p> Bluetooth: Actividad avanzada 1. Envio y recepci\u00f3n</p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#bt-actividad-avanzada-2","title":"BT: Actividad avanzada 2","text":"<p>En esta segunda actividad vamos a hacer algo similar a la actividad avanzada 2 de Telegram, es decir, enviaremos comandos (letras) a la ESP32 a trav\u00e9s de una app via Bluetooth y la placa nos responder\u00e1 con diferentes mensajes y datos.</p> <p>Comenzamos por el bloque 'Inicializar' que va a tener el siguiente aspecto:</p> <p> <p> Bluetooth: Actividad avanzada 2 </p> <p></p> <p>Los comandos soportados van a ser:</p> <ul> <li>Tecla T para obtener la temperatura de la ESP32. Corresponde al ASCII 84 decimal</li> <li>Tecla R para encender el LED rojo. Corresponde al ASCII 82 decimal</li> <li>Tecla A para encender el LED amarillo. Corresponde al ASCII 63 decimal</li> <li>Tecla V para encender el LED verde. Corresponde al ASCII 86 decimal</li> <li>Tecla N para apagar los tres LEDs. Corresponde al ASCII 110 decimal</li> </ul> <p> <p> Bluetooth: Actividad avanzada 2 Acceder al programa</p> <p></p> <p>Resultados obtenidos a trav\u00e9s de la app Bluetooth Terminal Qwerty:</p> <p> <p> Bluetooth: Actividad avanzada 2. Resultados </p> <p></p> <p>Resultados obtenidos a trav\u00e9s de la app Arduino Bluetooth Controller:</p> <p> <p> Bluetooth: Actividad avanzada 2. Resultados </p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#mando-nunchuk-de-la-wii","title":"Mando Nunchuk de la Wii","text":"<p>Este mando est\u00e1 compuesto por un joystick y un acelerometro:</p> <p> <p> Partes del mando </p> <p></p> <p>En la imagen vemos la localizaci\u00f3n del conector en la placa Imagina 3DBot:</p> <p> <p> Conector nunchuk en la placa Imagina 3DBot </p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#aav1_joystick-y-botones","title":"AAv1_Joystick y botones","text":"<p>Vamos a comenzar por leer los valores anal\u00f3gicos del joystick as\u00ed como el estado de los botones.</p> <p> <p> AAv1_Joystick y botones Acceder al programa</p> <p></p> <p>A continuaci\u00f3n vemos resultados de accionar el mando y pulsar los botones:</p> <p> <p> AAv1_Joystick y botones </p> <p></p>"},{"location":"Imagina/avanzadas_imagina/#aav2_acelerometro","title":"AAv2_Aceler\u00f3metro","text":"<p>Recordemos brevemente algunos conceptos:</p> <ul> <li>Se puede decir que la velocidad es una medida de la distancia que recorre un objeto en un tiempo dado.</li> <li>La aceleraci\u00f3n es una medida de c\u00f3mo cambia la velocidad. La aceleraci\u00f3n es algo que estamos acostumbrados a sentir en nuestro d\u00eda a d\u00eda, por ejemplo cuando avanzamos con un coche o cuando frenamos, o en un autob\u00fas, o la gravedad que nos atrae al lugar en el que estamos parados.</li> </ul> <p>Esto tiene su principio en la primera Ley de Newton o ley de inercia, que viene a decir que un cuerpo en reposo, permanecer\u00e1 en reposo hasta que una fuerza lo haga moverse, y al contrario, un cuerpo en movimiento se mantendr\u00e1 en movimiento hasta que una fuerza lo detenga.</p> <p>T\u00e9cnicamente es posible conseguir fabricar un condensador en el que la energia almacenada en el mismo, que depende de su geometria y de la distancia entre sus placas, pueda traducirse en saber la aceleraci\u00f3n que tiene.</p> <p>Un aceler\u00f3metro es un dispositivo capaz de medir la aceleraci\u00f3n inercial (\\(a=dv/dt\\)) que sufre el componente.</p> <p>La asegunda Ley de Newton o ley fundamental de la din\u00e1mica, nos indica que el cambio de movimiento es proporcional a la fuerza motriz que lo provoca, quedando descrito por su momento:</p> <p>\\(p=m \\cdot v;F=dp/dt \\rightarrow F=m \\cdot a\\)</p> <p>Un sensor de este tipo utiliza internamente componentes denominados MEMS (MicroElectroMechanical Systems) que son sistemas que llevan partes m\u00f3viles en su interior de forma que tenemos un cuerpo s\u00f3lido, en cuyo interior hay una masa sujeta por muelles al cuerpo exterior. La idea se explica mucho mejor observado la siguiente animaci\u00f3n extraida de https://howtomechatronics.com/.</p> <p> <p> Principio de funcionamiento de un aceler\u00f3metro </p> <p></p> <p>El aceler\u00f3metro del Nunchuk es de 3 ejes por lo que es capaz de medir aceleraciones en los 3 ejes: X, Y, Z.</p> <p> <p> Ejes del aceler\u00f3metro </p> <p></p> <p>En el bloque nunchuk se pueden adem\u00e1s seleccionar las siguientes opciones:</p> <p> <p> Opciones del bloque nunchuk </p> <p></p> <p>Los conceptos que vemos en la imagen se refieren a la rotaci\u00f3n del eje X (Roll) y la rotaci\u00f3n del eje Y (Pitch) y se ha prescindido del eje Z (Yaw). Para aprender mas sobre estos conceptos visita este enlace al blog de Luis Llamas. En la explicaci\u00f3n de los conceptos b\u00e1sicos de este tipo de dispositivos se muestra el gr\u00e1fico de la figura siguiente, donde se comparan los conceptos de movimientos angulares aplicados a una aeronave.</p> <p> <p> Movimientos angulares </p> <p></p> <p>Creamos un programa similar al anterior:</p> <p> <p> AAv2_Aceler\u00f3metro Acceder al programa</p> <p></p> <p>A continuaci\u00f3n vemos resultados de accionar el mando y pulsar los botones:</p> <p> <p> AAv2_Aceler\u00f3metro </p> <p></p>"},{"location":"Imagina/distribucion/","title":"Asociaci\u00f3n de pines y componentes","text":""},{"location":"Imagina/distribucion/#imagina-3dbot","title":"Imagina 3DBot","text":"<p>La asociaci\u00f3n de pines anal\u00f3gicos de entrada/salida con componentes es la siguiente:</p> <ul> <li>A0 / GPIO02 \u2192 Zumbador</li> <li>A1 / GPIO04 \u2192 Cualquier sensor o actuador</li> <li>A2 / GPIO35 \u2192 Sensor de luz (LDR)</li> <li>A3 / GPIO34 \u2192 Sensor de temperatura (NTC)</li> <li>A4 \u2192 Bus I2C</li> <li>A5 \u2192 Bus I2C</li> </ul> <p>La asociaci\u00f3n de pines digitales de entrada/salida con componentes es la siguiente:</p> <ul> <li>D0 / RX0 \u2192 Bluetooth RX</li> <li>D1 / TX0 \u2192 Bluetooth TX</li> <li>D2 / GPIO26 \u2192 Sensor de ultrasonidos (ECHO), pulsador</li> <li>D3 / GPIO25 \u2192 LED verde, emisor infrarrojos <li>D4 / GPIO17 \u2192 Sensor de ultrasonidos (TRIG)</li> <li>D5 / GPIO16 \u2192 LED amarillo, sensor de l\u00ednea izquierdo <li>D6 / GPIO27 \u2192 LED rojo, sensor de l\u00ednea derecho <li>D7 / GPIO14 \u2192 Motor A (izquierdo)</li> <li>D8 / GPIO12 \u2192 Motor A</li> <li>D9 / GPIO13 \u2192 Motor A</li> <li>D10 / GPIO05 \u2192 Motor B (derecho)</li> <li>D11 / GPIO23 \u2192 Receptor de infrarrojos</li> <li>D12 / GPIO19 \u2192 Motor B</li> <li>D13 / GPIO18 \u2192 Motor B</li>"},{"location":"Imagina/distribucion/#pines-imagina-3dbot-esp32-steamakers","title":"Pines Imagina 3DBot - ESP32 STEAMakers","text":"<p>El grupo de pines D0 a D13 tienen la siguiente correspondencia entre las dos placas:</p> <p> <p> </p> <p></p> <p>El grupo de pines A0 a A5, SDA y SCL tienen la siguiente correspondencia entre las dos placas:</p> <p> <p> </p> <p></p> <p>El resto de pines tienen la siguiente correspondencia entre las dos placas:</p> <p> <p> </p> <p></p>"},{"location":"Imagina/introImagina/","title":"Placa Imagina 3DBot","text":"<p>El aspecto de la cara anterior o top de la placa se ve en la imagen siguiente:</p> <p> <p> Cara top de la placa Imagina</p> <p></p> <p>En la imagen siguiente vemos la placa con un m\u00f3dulo Bluetooth insertado en su z\u00f3calo.</p> <p> <p> Cara top de la placa Imagina con un m\u00f3dulo Bluetooth</p> <p></p> <p>El aspecto de la cara posterior o bottom de la placa se ve en la imagen siguiente:</p> <p> <p> Cara bottom de la placa Imagina</p> <p></p> <p>La imagen siguiente nos muestra de forma gr\u00e1fica la funcionalidad de los distintos elementos de la placa Imagina 3DBot V4:</p> <p> <p> Elementos que conforman  la placa Imagina</p> <p></p>"},{"location":"Miscelanea/about/","title":"Autor","text":"<p>Federico Coca</p> <ul> <li> <p>GitHub</p> </li> <li> <p>X</p> </li> <li> <p>Instagram</p> </li> <li> <p>Mas informaci\u00f3n</p> </li> </ul>"},{"location":"Miscelanea/lic/","title":"Licencias","text":"<ul> <li> <p>Licencia MIT incluida en la creaci\u00f3n del repositorio.</p> </li> <li> <p>Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0 </p> </li> </ul> <p> <p> </p> <p></p>"},{"location":"Miscelanea/soft/","title":"Software utilizado","text":"<ul> <li> <p>Sistema operativo: Ubuntu Ubuntu 22.04.3 LTS  (Jammy Jellyfish)</p> </li> <li> <p>Paquete ofim\u00e1tico de referencia: LibreOffice</p> </li> <li> <p>Libreria Material para MkDocs</p> </li> <li> <p>Visual Studio Code</p> </li> <li> <p>plantilla-taller</p> </li> <li> <p>Creaci\u00f3n de GIF animados para Ubuntu Peek</p> </li> <li> <p>Sistema principal de capturas de pantalla: Shutter</p> </li> <li> <p>Dibujo 2D vectorial Inkscape</p> </li> <li> <p>Retoque de im\u00e1genes GIMP</p> </li> <li> <p>Generador de tablas para Markdown Tables Generator</p> </li> <li> <p>Arduinoblocks</p> </li> <li> <p>AB-Connector</p> </li> <li> <p>Arduino IDE Version 2.3.2 Copyright \u00a9 2024 Arduino SA</p> </li> <li> <p>Fritzing Version 0.9.6</p> </li> </ul>"},{"location":"Miscelanea/webgrafia/","title":"Webgraf\u00eda y bibliograf\u00eda","text":"<ul> <li> <p>Wikipedia</p> </li> <li> <p>plantilla-taller desarrollada por Cristobal Contreras para La Jaquer\u00eda</p> </li> <li> <p>Contenidos del aula virtual Robolot Formaci\u00f3 creados por Toni Hortal para Robolot</p> </li> <li> <p>Libros &amp; Documentaci\u00f3n de Arduinoblocks</p> </li> <li> <p>Web de Francisco Soldado Ardutaller</p> </li> </ul>"},{"location":"arduinoblocks/gestionados/","title":"Usuarios gestionados","text":"<p>Permite a un usuario registrado con correo electr\u00f3nico, crear y administrar nuevas cuentas de usuario dentro de una organizaci\u00f3n, centro educativo o instituci\u00f3n.</p> <p>Permite a los profesores crear usuarios para sus alumnos.</p> <p>Permite crear cuentas a usuarios que no disponen de correo electr\u00f3nico o que su correo est\u00e1 limitado por pol\u00edticas del centro.</p> <p>Los usuarios pueden fijar su propia clave, el administrador podr\u00e1 regenerar nuevas claves en caso de p\u00e9rdida.</p> <p>Los usuarios gestionados tienen algunas limitaciones:</p> <ul> <li>No pueden compartir proyectos p\u00fablicamente ni con otros usuarios.</li> <li>No pueden importar proyectos desde archivo ni desde otros proyectos compartidos.</li> <li>No pueden adjuntar archivos a los proyectos.</li> <li>La informaci\u00f3n del perfil s\u00f3lo la puede modificar el administrador/profesor.</li> <li>Pueden crear proyectos personales y se podr\u00e1n unir a proyectos como estudiante si el c\u00f3digo de proyecto pertenece a un profesor que es administrador de la organizaci\u00f3n.</li> </ul> <p> <p> Usuarios gestionados </p> <p></p> <p>Para acceder, una vez iniciada sesi\u00f3n en Arduinoblocks, hacemos clic sobre nuestro nombre de usuario (parte superior derecha) y escogemos 'Usuarios gestionados'.</p> <p> <p> Acceso a Usuarios gestionados </p> <p></p>"},{"location":"arduinoblocks/gestionados/#crear-organizacion","title":"Crear organizaci\u00f3n","text":"<p>Haz clic en el bot\u00f3n 'Nueva organizaci\u00f3n':</p> <p> <p> Nueva organizaci\u00f3n </p> <p></p> <ul> <li>El nombre de la organizaci\u00f3n debe representar al centro, organizaci\u00f3n, academia, instituci\u00f3n, curso, ...</li> <li>La longitud m\u00ednima del nombre es de 6 caracteres.</li> <li>Los caracteres permitidos son: a-z 0-9 _</li> <li>No se permiten espacios ni letras may\u00fasculas en el nombre</li> <li>Dentro de la organizaci\u00f3n las cuentas ser\u00e1n: [nombre].[organizaci\u00f3n]</li> </ul> <p>Escribe el nombre de la organizaci\u00f3n y clica en el bot\u00f3n 'Nuevo dominio':</p> <p> <p> Nuevo dominio </p> <p></p> <p>Aparecer\u00e1 una p\u00e1gina con un contenido similar al siguiente:</p> <p> <p> Usuarios gestionados con un dominio </p> <p></p>"},{"location":"arduinoblocks/gestionados/#crear-usuario-gestionado","title":"Crear usuario gestionado","text":"<ul> <li>No podr\u00e1n crearse dos usuarios iguales para la misma organizaci\u00f3n.</li> <li>El usuario no podr\u00e1 cambiar ni el identificador de usuario ni el nombre descriptivo.</li> <li>El usuario podr\u00e1 cambiar su clave.</li> <li>La longitud m\u00ednima del identificador es de 6 caracteres.</li> <li>Los caracteres permitidos son: a-z 0-9 _</li> </ul> <p>Haz clic en el bot\u00f3n 'Nuevo usuario':</p> <p> <p> Nuevo usuario gestionado </p> <p></p> <p>Cuando tengamos los datos listos hacemos clic en el bot\u00f3n 'Nuevo usuario gestionado' y en la p\u00e1gina de 'Usuarios gestionados' mostrar\u00e1 el nuevo usuario:</p> <p> <p> Nuevo usuario gestionado </p> <p></p> <p>Diferencias entre los perfiles de administrador principal y usuario gestionado:</p> <p> <p> Diferencias entre usuarios </p> <p></p>"},{"location":"arduinoblocks/gestionados/#eliminar-organizacion-yo-usuarios","title":"Eliminar organizaci\u00f3n y/o usuarios","text":"<p>Justo debajo de la lista de usuarios tenemos los dos botones siguientes:</p> <p> <p> Botones eliminar usuarios y organizaci\u00f3n </p> <p></p> <p>Con el bot\u00f3n 'Eliminar todos los usuarios' podemos eliminar todos los usuarios de una organizaci\u00f3n. Con el bot\u00f3n 'Eliminar organizaci\u00f3n + todos los usuarios' se eliminar\u00e1n la organizaci\u00f3n y todos los usuarios y sus proyectos.</p> <p>El \u00fanico usuario que dispone de estas dos opciones es el creador del dominio.</p> <p>Para aliminar un usuario concreto tenemos disponible la papelera a la derecha de su nombre.</p>"},{"location":"arduinoblocks/gestionados/#anadir-coadministradores","title":"A\u00f1adir coadministradores","text":"<ul> <li>Podemos a\u00f1adir a otros usuarios como coadministradores de la organizaci\u00f3n.</li> <li>S\u00f3lo el usuario administrador principal (creador de la organizaci\u00f3n) puede eliminarlos.</li> <li>Los usuarios coadministradores no pueden a\u00f1adir ni eliminar otros coadministradores.</li> <li>Los usuarios coadministradores pueden gestionar a los usuarios como el usuario administrador principal.</li> </ul> <p>Para a\u00f1adir un coadministrador, en la p\u00e1gina principal de usuarios gestionados, hacemos clic en el bot\u00f3n 'A\u00f1adir administrador/profesor...'. Pedir\u00e1 el correo electr\u00f3nico del coadministrador:</p> <p> <p> A\u00f1adiendo usuario coadministrador </p> <p></p>"},{"location":"arduinoblocks/gestionados/#iniciar-sesion-desde-una-cuenta-gestionada","title":"Iniciar sesi\u00f3n desde una cuenta gestionada","text":"<p>En la ventana de inicio de sesi\u00f3n, en 'Correo electr\u00f3nico' el usuario debe escribir el correo electr\u00f3nico otorgado en la organizaci\u00f3n que tendr\u00e1 un formato de tipo 'nombre.organizaci\u00f3n':</p> <p> <p> Inicio de sesi\u00f3n como usuario gestionado </p> <p></p>"},{"location":"arduinoblocks/gestionados/#nuevo-proyecto-de-usuario-gestionado","title":"Nuevo proyecto de usuario gestionado","text":"<p>Una vez iniciada la sesi\u00f3n, el usuario gestionado puede iniciar un nuevo proyecto personal clicando en el bot\u00f3n 'Mis proyectos' o unirse al proyecto de un profesor clicando en el bot\u00f3n 'Empezar un nuevo proyecto!':</p> <p> <p> Opciones tras inicio de sesi\u00f3n de usuario gestionado </p> <p></p> <p>En el primer caso se mostrar\u00e1 un listado de los proyectos del usuario gestionado y en el segundo caso el usuario gestionado puede iniciar un proyecto personal o escribir el c\u00f3digo del proyecto y clicar en el bot\u00f3n 'Unirme al proyecto de mi profesor':</p> <p> <p> Opciones de 'Empezar un nuevo proyecto!' </p> <p></p> <p>IMPORTANTE: El profesor que genera el c\u00f3digo debe ser administrador de la organizaci\u00f3n a la que pertenece el usuario."},{"location":"arduinoblocks/introAB/","title":"Introducci\u00f3n a Arduinoblocks","text":"<p>Arduinoblocks es una plataforma web de funcionamiento en l\u00ednea (online) donde podemos programar las placas soportadas de forma visual sin necesidad de conocer el lenguaje C++ que utiliza el IDE de Arduino, aunque dicho lenguaje en realidad est\u00e1 detr\u00e1s de los bloques. Las placas soportadas a fecha de publicaci\u00f3n de esta web son:</p> <p> <p> Placas soportadas</p> <p></p> <p>La programaci\u00f3n con Arduinoblocks se hace con bloques al estilo de App Inventor, Scratch, Snap!, MicroBlocks u otros. No hay que escribir l\u00edneas de c\u00f3digo y no nos permitir\u00e1 unir bloques incompatibles, evitando as\u00ed posibles errores de sintaxis.</p> <p>La plataforma Arduinoblocks genera, compila y sube el programa a la placa por medio de la conexi\u00f3n USB. Una vez subido el programa, la placa microcontrolada no necesitar\u00e1 estar conectada al ordenador para funcionar, pudiendola alimentar con baterias o una fuente de alimentaci\u00f3n para que funcione de forma autonoma.</p> <p>Arduinoblocks actualmente funciona con los navegadores de \u00faltima generaci\u00f3n: Mozilla Firefox, Google Chrome, Falkon, Chromium, Microsof Edge, Opera y Safari.</p> <p>Registr\u00e1ndonos como usuarios en la plataforma Arduinoblocks podemos aprovechar las siguientes posibilidades:</p> <ul> <li>Guardar tus proyectos en la nube de ArduinoBlocks</li> <li>A\u00f1adir informaci\u00f3n al proyecto: descripci\u00f3n, componentes utilizados, im\u00e1genes, etc.</li> <li>A\u00f1adir archivos adjuntos relacionados con el proyecto: esquemas, fotos, archivos para impresi\u00f3n 3D, aplicaciones\u2026</li> <li>Compartir proyectos con el resto del mundo</li> <li>Importar proyectos compartidos por otros usuarios</li> <li>Valorar y comentar proyectos</li> <li>Programar directamente la placa microcontrolada desde el propio navegador (con la aplicaci\u00f3n ArduinoBlocks-Connector)</li> <li>Utilizar la consola serie desde el propio navegador</li> </ul>"},{"location":"arduinoblocks/introAB/#software-necesario","title":"Software necesario","text":"<p>Para llevar a cabo la programaci\u00f3n de las actividades es necesario estar registrado en Arduinoblocks y se recomienda hacerlo con un nombre real para posteriormente facilitar la localizaci\u00f3n si es necesaria y se tiene que hacer con un correo v\u00e1lido pues se necesita confirmaci\u00f3n para crear la cuenta.</p> <ul> <li>La tarea es sencilla y est\u00e1 perfectamente descrita en el Free Book (online &amp; updated) que podemos encontrar en los recursos de la plataforma www.arduinoblocks.com.</li> <li>Creamos un \"nuevo usuario\" utilizando para ello una cuenta de correo v\u00e1lida donde vamos a recibir un correo de confirmaci\u00f3n para activarla.</li> <li>Ya estamos en condiciones de crear nuestros propios proyectos en la plataforma como veremos mas adelante.</li> </ul> <p> <p> Crear un nuevo proyecto</p> <p></p> <ul> <li>Descarga e instala en tu ordenador y para tu sistema operativo la \u00faltima versi\u00f3n de ArduinoBlocks - Connector. Este programa vamos a necesitarlo para poder comunicar nuestra placa con la plataforma a trav\u00e9s del puerto USB de nuestro ordenador.</li> </ul> <p>En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5 del programa una vez iniciado la vemos en la imagen siguiente:</p> <p>El programa debe estar en ejecuci\u00f3n, minimizado para que no nos moleste, siempre que queramos grabar un programa y tiene el aspecto que vemos en la figura siguiente:</p> <p> <p> ArduinoBlocks Connector</p> <p></p>"},{"location":"arduinoblocks/introAB/#plataforma","title":"Plataforma","text":"<p>El aspecto de la plataforma al entrar lo vemos en la imagen siguiente:</p> <p> <p> Portada de la plataforma ArduinoBlocks</p> <p></p> <p>Podemos programar nuestra placa de control de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y Arduinoblocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE.</p> <p> <p> Comparativa entre bloques y c\u00f3digo</p> <p></p> <p>Es importante entender que la programaci\u00f3n con Arduinoblocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla.</p>"},{"location":"arduinoblocks/introAB/#inicio-de-sesion","title":"Inicio de sesi\u00f3n","text":"<p>Para trabajar tenemos que iniciar sesi\u00f3n haciendo clic en Iniciar sesi\u00f3n:</p> <p> <p> Bot\u00f3n y entrada inicio de sesi\u00f3n</p> <p></p> <p>Una vez iniciada sesi\u00f3n tendremos acceso a nuestros proyectos en la nube y a todas las ventajas de la comunidad Arduinoblocks.</p>"},{"location":"arduinoblocks/introAB/#creacion-de-un-nuevo-proyecto","title":"Creaci\u00f3n de un nuevo proyecto","text":"<p>Para iniciar un nuevo proyecto hacemos clic en el men\u00fa Proyectos \u2192 Nuevo proyecto:</p> <p> <p> Nuevo proyecto</p> <p></p> <p>Seleccionamos el tipo de proyecto:</p> <p> <p> Tipo de proyecto</p> <p></p> <p>En caso de seleccionar un proyecto personal (el caso mas usual) a continuaci\u00f3n tenemos que seleccionar el tipo de placa a utilizar. Hay que indicar un nombre descriptivo, preferiblemente corto, y una descripci\u00f3n mas detallada. En la secci\u00f3n componentes se puede indicar el listado de material necesario para el llevar a cabo el proyecto.</p> <p> <p> Datos del proyecto</p> <p></p> <p>Los editores de texto asociados son muy sencillos de manejar y se pueden crear enlaces a informaci\u00f3n detallada del componente o donde comprarlo.</p>"},{"location":"arduinoblocks/introAB/#area-de-programacion","title":"Area de programaci\u00f3n","text":"<p>En la figura siguiente vemos destacadas las principales secciones del \u00e1rea de programaci\u00f3n.</p> <p> <p> Principales secciones del \u00e1rea de programaci\u00f3n</p> <p></p> <p>Para a\u00f1adir bloques al programa los arrastramos desde la barra de herramientas al \u00e1rea de programaci\u00f3n, insertandolos dentro del bloque Inicializar o del bloque Bucle, o independiente si se trata de una funci\u00f3n.</p> <p>Los bloques que est\u00e9n fuera del bloque Inicializar o del bloque Bucle del programa principal ser\u00e1n ignorados a la hora de generar el programa (excepto los bloques de funciones).</p> <p>Arduinoblocks genera el c\u00f3digo C++ a partir de los bloques. El programa puede compilarse y subirse directamente a la placa gracias a la aplicaci\u00f3n Arduinoblocks-Connector. Sin embargo, si queremos ver o descargar el c\u00f3digo lo podemos hacer desde el \u00e1rea de bloques.</p> <p> <p> Descarga o visualizaci\u00f3n del c\u00f3digo</p> <p></p> <p>Si descargamos o copiamos el c\u00f3digo generado por Arduinoblocks en el IDE de Arduino podemos necesitar algunas librer\u00edas no incluidas en nuestro IDE.</p> <p>Para solucionarlo debemos descargarlas y a\u00f1adirlas a Arduino IDE para una correcta compilaci\u00f3n del programa, o utilizar la opci\u00f3n descargar .zip para Arduino IDE, lo que nos facilitar\u00e1 un archivo comprimido con el c\u00f3digo de nuestro programa y todas las librer\u00edas necesarias incluidas en la misma carpeta.</p> <p>M\u00e1s informaci\u00f3n sobre las librer\u00edas de ArduinoBlocks</p> <p>La opci\u00f3n m\u00e1s r\u00e1pida y sencilla es la compilaci\u00f3n y programaci\u00f3n directa desde el propio navegador junto a la aplicaci\u00f3n ArduinoBlocks-Connector</p>"},{"location":"arduinoblocks/introAB/#area-de-informacion","title":"Area de informaci\u00f3n","text":"<p>Un proyecto electr\u00f3nico debe estar siempre correctamente documentado.</p> <p>En la secci\u00f3n Informaci\u00f3n podemos a\u00f1adir informaci\u00f3n o modificar la indicada durante la creaci\u00f3n del proyecto.</p> <p> <p> Informaci\u00f3n del proyecto</p> <p></p> <p>En la figura siguiente vemos un ejemplo de documentaci\u00f3n para un proyecto concreto.</p> <p> <p> Informaci\u00f3n del proyecto</p> <p></p> <p>Seleccionando la opci\u00f3n Proyecto p\u00fablico podemos hacer que nuestro proyecto est\u00e9 disponible de forma p\u00fablica para que otros usuarios lo busquen y localicen (sin posibilidad de editar) y que puedan importar una copia para tenerlo dentro de sus propios contenidos.</p> <p> <p> Informaci\u00f3n del proyecto: Proyecto p\u00fablico</p> <p></p> <p>Al marcar nuestro proyecto como \"p\u00fablico\" aparecer\u00e1 en la lista de b\u00fasqueda de proyectos compartidos para todos los usuarios de Arduinoblocks.</p>"},{"location":"arduinoblocks/introAB/#area-de-ficheros-adjuntos","title":"Area de ficheros adjuntos","text":"<p>De igual forma podemos adjuntar im\u00e1genes, hojas de datos o cualquier otro archivo relacionado con el proyecto.</p> <p> <p> Archivos</p> <p></p>"},{"location":"arduinoblocks/introAB/#guardar","title":"Guardar","text":"<p>Arduinoblocks guarda autom\u00e1ticamente el proyecto cada cierto tiempo. En el caso de querer asegurarnos el guardado podemos clicar en el bot\u00f3n \u201cGuardar\u201d.</p> <p> <p> Guardar</p> <p></p> <p>Tambi\u00e9n podemos crear un nuevo proyecto a partir de la actual pulsando la opci\u00f3n \"Guardar como...\". Autom\u00e1ticamente se abrir\u00e1 el nuevo proyecto creado a partir del primero.</p>"},{"location":"arduinoblocks/introAB/#barra-de-informacion","title":"Barra de informaci\u00f3n","text":"<p>En la parte inferior derecha podemos obtener la informaci\u00f3n de guardado y algunos avisos que nos muestra la aplicaci\u00f3n.</p> <p> <p> Barra de informaci\u00f3n</p> <p></p> <p>En la parte inferior izquierda de la barra tenemos las opciones que se muestran en la figura siguiente:</p> <p> <p> Barra de informaci\u00f3n</p> <p></p>"},{"location":"arduinoblocks/introAB/#importar-proyecto","title":"Importar proyecto","text":"<p>Si accedemos a visualizar un proyecto compartido por otro usuario, aparecer\u00e1 un bot\u00f3n \u201cImportar a mis proyectos\u201d, con el que podemos crear una copia del proyecto a nuestros proyectos personales para poder modificarlo seg\u00fan nuestras propias necesidades. En la animaci\u00f3n vemos el proceso de b\u00fasqueda, su resultado y como nos aparece el bot\u00f3n Importar a mis proyectos cuando seleccionamos uno de ellos.</p> <p> <p> Importar proyecto</p> <p></p> <p>El resultado de hacer clic en el bot\u00f3n Importar a mis proyectos lo vemos en la figura siguiente:</p> <p> <p> Importar proyecto</p> <p></p>"},{"location":"arduinoblocks/introAB/#iconos-del-editor","title":"Iconos del editor","text":"<p> <p> Iconos del editor</p> <p></p> <p>En el video podemos ver el uso de la mochila.</p>"},{"location":"arduinoblocks/introAB/#area-de-programacion_1","title":"\u00c1rea de programaci\u00f3n","text":""},{"location":"arduinoblocks/introAB/#estructura-de-un-proyecto","title":"Estructura de un proyecto","text":"<p>Un proyecto tipo Arduino tiene siempre dos estructuras importantes en su interior, y esto se ve reflejado claramente al crear un nuevo proyecto en Arduinoblocks:</p> <p> <p></p> <p></p> <ul> <li> <p>Bloque 'Inicializar' o 'Setup'</p> <p>El contenido de este bloque se ejecuta una sola vez duante el inicio del microcontrolador, o si pulsamos el bot\u00f3n de reset y la placa se reinicia</p> <p>El bloque se utiliza para inicializar variables, configurar sensores, actuadores, perif\u00e9ricos, etc</p> </li> </ul> <p> <p></p> <p></p> <ul> <li> <p>Bloque 'Bucle' o 'Loop'</p> <p>El contenido de este bloque se repite indefinidamente</p> <p>Dentro de este bloque a\u00f1adiremos los bloques de nuestro programa con la funcionalidad deseada</p> </li> </ul> <p>Cualquier bloque que no est\u00e9 dentro del bloque 'Inicializar' o del bloque 'Bucle' y no forme parte de una funci\u00f3n ser\u00e1 ignorado a la hora de compilar el c\u00f3digo.</p> <p>En la figura siguiente vemos un ejemplo que al al iniciar se establece la variable a 0; se env\u00eda y se incrementa cada segundo indefinidamente.</p> <p> <p> Enlace a ejemplo 3DB_Ej1</p> <p></p> <p>En el siguiente ejemplo, al iniciar (o hacer reset) se env\u00eda un mensaje por el puerto serie; el LED rojo se enciende; espera 500 ms; se apaga y espera otros 500 ms (este ciclo se repetir\u00e1 indefinidamente).</p> <p> <p> Enlace a ejemplo 3DB_Ej2</p> <p></p> <p>Importante: el \u201cbootloader\u201d  normalmente tiene configurada la opci\u00f3n de realizar un reset al microcontrolador cuando se inicia una conexi\u00f3n serie. Por tanto, si conectamos con la consola serie del ordenador hay que tener en cuenta que se reiniciar\u00e1 el programa y se ejecutar\u00e1 el bloque \u201cInicializar\u201d.</p>"},{"location":"arduinoblocks/introAB/#configuracion-de-bloques","title":"Configuraci\u00f3n de bloques","text":"<p>Algunos bloques permiten configurar o alterar su funcionamiento. Para desplegar las opciones posibles pulsamos sobre el icono superior izquierdo del bloque con apariencia de signo mas (+). En la animaci\u00f3n siguiente vemos ejemplos de lo dicho.</p> <p> <p> Configurando bloques </p> <p></p>"},{"location":"arduinoblocks/introAB/#comentarios","title":"Comentarios","text":"<p>Si necesitamos a\u00f1adir un comentario a un bloque desplegamos las opciones del mismo clicando con el bot\u00f3n derecho del rat\u00f3n y escogiendo 'A\u00f1adir comentario', aparecer\u00e1 un signo de interrogaci\u00f3n sobre el que podemos hacer clic para que se abra un bocadillo de texto donde podemos escribir nuestro comentario.</p> <p> <p> Comentarios </p> <p></p> <p>Otras opciones de bloque disponibles al pulsar el bot\u00f3n derecho del rat\u00f3n son:</p> <ul> <li> <p>Duplicar     Crea una copia del bloque actual</p> </li> <li> <p>Entradas externas (en linea)     Modifica el aspecto del bloque de forma compacta o una l\u00ednea</p> </li> <li> <p>Contraer / Expandir bloque     Reduce el tama\u00f1o del bloque para ahorrar espacio mientras no necesitamos editarlo</p> </li> <li> <p>Desactivar bloque     El compilador no tendr\u00e1 en cuenta este bloque</p> </li> <li> <p>Eliminar / Eliminar x bloques     Elimina el bloque o el conjunto de bloques</p> </li> <li> <p>Ayuda     Abre un enlace con ayuda sobre la funci\u00f3n del bloque.</p> </li> </ul>"},{"location":"arduinoblocks/proyectos_alumnos/","title":"Creaci\u00f3n de proyectos para alumnos","text":"<p>Tanto si tus alumnos se han dado de alta con una cuenta propia como si has creado sus usuarios gestionados, como profesor puedes crear proyectos e invitar a tus alumnos a unirse a ellos.</p> <p>De esta forma, cada alumno trabajar\u00e1 en su proyecto y t\u00fa podr\u00e1s supervisar, valorar y comentar el trabajo realizado por todos ellos.</p> <p>Empieza iniciando sesi\u00f3n en ArduinoBlocks y clicando en Proyectos \u2192 Nuevo proyecto:</p> <p> <p> Creaci\u00f3n de un nuevo proyecto </p> <p></p> <p>De las 3 opciones que aparecen, elige la de 'Crear un proyecto para mis alumnos':</p> <p> <p> Crear un proyecto para mis alumnos </p> <p></p> <p>Selecciona el 'Tipo de proyecto' y escribe un 'Nombre'. \u00c9stos son los dos campos obligatorios del formulario. El resto de campos es opcional. Pulsa en el bot\u00f3n 'Nuevo proyecto':</p> <p> <p> Crear un proyecto para mis alumnos </p> <p></p> <p>El nuevo proyecto aparece en la p\u00e1gina 'Mis proyectos':</p> <p> <p> Proyecto para alumnos </p> <p></p> <p>\u00a1Ten cuidado! \u00a1La acci\u00f3n de borrado es irreversible!</p> <p>En la p\u00e1gina de creaci\u00f3n/edici\u00f3n de un proyecto para alumnos puedes crear un grupo nuevo o seleccionar un grupo de entre los existentes (creados anteriormente). Esta opci\u00f3n la encontrar\u00e1s en el tercer campo del formulario:</p> <p> <p> Seleccionar grupo </p> <p></p> <p>Tambi\u00e9n puedes establecer una fecha l\u00edmite para la inscripci\u00f3n en el proyecto. Esta opci\u00f3n la encontrar\u00e1s en el \u00faltimo campo del formulario:</p> <p> <p> Fecha l\u00edmite de inscripci\u00f3n </p> <p></p>"},{"location":"ayuda/ayuda/","title":"Ayuda","text":"<p>TODO:</p> <p>Esta es una secci\u00f3n de ayuda para cuando tengas problemas escribiendo el taller. \u00dasalo como consulta mientras lo est\u00e1s redactando (el taller), pero recuerda comentarlo en el <code>mkdocs.yml</code> para que no aparezca en tu web.</p> <p><code>mkdocs.yml</code> -&gt; Debe quedar el punto 5 m\u00e1s o menos as\u00ed</p> <pre><code>...\n\n# 5. Navegaci\u00f3n\nnav:\n  - Introducci\u00f3n: index.md\n  - Autor / Autores: about.md\n  - Instalaci\u00f3n:\n    - Windows: instalacion/windows.md\n    - Mac OS: instalacion/macos.md\n    - Linux: instalacion/linux.md\n  - ...\n#  - Chuletas para escribir:\n#    - Ayuda: ayuda/ayuda.md\n#    - Markdown: ayuda/markdown.md\n#    - Material Design: ayuda/material.md\n\n...\n</code></pre> <p>Tienes una ayuda b\u00e1sica para desenvolverte con Markdown. Y otra para poder sacarle m\u00e1s partido al tema Material Design:</p> <ol> <li>Escribir Markdown</li> <li>Sacarle jugo al tema Material Design</li> </ol>"},{"location":"ayuda/markdown/","title":"Chuleta de Markdown","text":"<p>Esta es solo una chuleta de Markdown b\u00e1sico. En esta web tienes una referencia muy buena -&gt; Web de Markdown.</p> <p>Para escribir Markdown se recomienda usar como editor VSCode o VSCodium con las extensiones:</p> <ul> <li>Markdown All in One</li> <li>Markdownlint</li> </ul>"},{"location":"ayuda/markdown/#titulos","title":"T\u00edtulos","text":""},{"location":"ayuda/markdown/#esto-es-un-titulo-1-usar-solo-al-principio-del-fichero","title":"Esto es un t\u00edtulo 1 -&gt; Usar solo al principio del fichero","text":""},{"location":"ayuda/markdown/#esto-es-un-titulo-2-usar-para-dividir-en-secciones","title":"Esto es un t\u00edtulo 2 -&gt; Usar para dividir en secciones","text":""},{"location":"ayuda/markdown/#esto-es-un-titulo-3-usar-para-dividir-en-subsecciones","title":"Esto es un t\u00edtulo 3 -&gt; Usar para dividir en subsecciones","text":""},{"location":"ayuda/markdown/#esto-es-un-titulo-4-no-recomendado-su-uso","title":"Esto es un t\u00edtulo 4 -&gt; No recomendado su uso","text":""},{"location":"ayuda/markdown/#esto-es-un-titulo-5-no-recomendado-su-uso","title":"Esto es un t\u00edtulo 5 -&gt; No recomendado su uso","text":""},{"location":"ayuda/markdown/#esto-es-un-titulo-6-no-recomendado-su-uso","title":"Esto es un t\u00edtulo 6 -&gt; No recomendado su uso","text":""},{"location":"ayuda/markdown/#textos","title":"Textos","text":"<p>Texto en negrita. Texto en cursiva.  </p> <p>Para poner un salto de linea tienes que poner dos espacios en blanco despu\u00e9s del punto. Esta l\u00ednea est\u00e1 debajo. Pero esta sale seguido.</p> <p>O debes de poner una l\u00ednea vac\u00eda entre medias.</p>"},{"location":"ayuda/markdown/#enlaces","title":"Enlaces","text":"<p>As\u00ed se pone un enlace a una p\u00e1gina de Internet.</p> <p>As\u00ed se pone un enlace a una p\u00e1gina del propio taller.</p>"},{"location":"ayuda/markdown/#imagenes","title":"Im\u00e1genes","text":"<p>As\u00ed se pone una imagen desde Internet</p> <p></p> <p>Y as\u00ed se pone una imagen desde el propio taller</p> <p></p>"},{"location":"ayuda/markdown/#listas","title":"Listas","text":"<p>Listas sin orden con <code>*</code>, ejemplo:</p> <ul> <li>Esto es una lista</li> <li>Lista sin orden.</li> </ul> <p>Listas ordenadas con <code>1.</code>, ejemplo:</p> <ol> <li>Esto es una</li> <li>Lista ordenada</li> </ol>"},{"location":"ayuda/markdown/#citas","title":"Citas","text":"<p>Si quieres poner una cita tienes que usar <code>&gt;</code> delante del texto, ejemplo:</p> <p>Esto es una cita</p> <p>Esto es una cita anidada</p> <p>Esto es una cita doblemente anidada</p>"},{"location":"ayuda/markdown/#regla-horizontal","title":"Regla horizontal","text":"<p>Se hace para poner una l\u00ednea que divisa visualmente una secci\u00f3n de otra.</p> <p>Aqu\u00ed hay una.</p>"},{"location":"ayuda/markdown/#tablas","title":"Tablas","text":"<p>En este ejemplo tienes una tabla con 3 columnas:</p> <ul> <li>La primera tiene el texto fijado a la izquierda.</li> <li>La segunda tiene el texto fijado al centro.</li> <li>La tercera tiene el texto fijado a la derecha.</li> </ul> Texto a la izquierda Texto en el centro Texto en la derecha En un lugar de la mancha, de cuyo nombre no quiero acordarme, no ha mucho tiempo que vivia un hidalgo de los de lanza en astillero, adarga antigua, roc\u00edn flaco y galgo corredor..."},{"location":"ayuda/markdown/#lineas-de-codigo","title":"L\u00edneas de c\u00f3digo","text":"<p>Para poner c\u00f3digo en l\u00ednea, tienes que ponerlo entre las comillas `.</p> <p>Aqu\u00ed tienes <code>un ejemplo de c\u00f3digo</code> en l\u00ednea.</p> <p>Si quisieras poner un bloque de c\u00f3digo tienes que poner 3 comillas `, debajo el c\u00f3digo, y una \u00faltima l\u00ednea con otras 3 comillas. Puedes incluso espec\u00edficarle el lenguaje del c\u00f3digo para que te lo coloree. Ah\u00ed va un ejemplo en Python:</p> <pre><code>import antigravity\n\nprint('Hola mundo')\n</code></pre>"},{"location":"ayuda/material/","title":"Material Design","text":"<p>Esta chuleta es un copia-pega modificado de esta p\u00e1gina. B\u00e1sicamente es un Markdown espec\u00edfico para poder ser usado con el tema Material Design y sacarle m\u00e1s partido.</p>"},{"location":"ayuda/material/#enlaces","title":"Enlaces","text":"<p>Existe la posibilidad de utilizar referencias a enlaces que se definen posteriormente. En ese caso unicamente incluimos el n\u00famero de enlace. M\u00e1s adelante es necesario definir el enlace que corresponde con cada n\u00famero y, opcionalmente, un texto descriptivo.</p> <pre><code>:::markdown\nPodemos comprar un ordenador (Dell)[1] o (Apple)[2].\n\n[1]: http://dell.com/   \"Comprar en Dell\"\n[2]: http://apple.com/  \"Comprar en Apple\"\n</code></pre> <p>Podemos comprar un ordenador Dell o Apple.</p>"},{"location":"ayuda/material/#imagenes","title":"Imagenes","text":"<p>Tambi\u00e9n es posible utilizar referencias que es necesario definir posteriormente.</p> <pre><code>:::markdown\n![texto alternativo][id]\n\n[id]: /img/md-logo.png \"Titulo opcional\"\n</code></pre> <p></p>"},{"location":"ayuda/material/#secuencias-de-escape","title":"Secuencias de escape","text":"<p>Puede ocurrir que alguno de los caracteres especiales utilizados en markdown aparezcan de forma fortuita en el texto y originen efectos no deseados. Para evitarlo podemos utilizar las secuencias de escape para especificar que deseamos utilizar el caracter como texto sin que tenga ning\u00fan efecto colateral. Podemos utilizar el caracter '\\' junto con cualquiera de los siguientes para crear una secuencia de escape.</p> <pre><code>\\ backslash\n` backtick\n* asterisco\n_ underscore\n{} curly braces\n[] square brackets\n() parentheses\n# hash mark\n+ plus sign\n- minus sign (hyphen)\n. dot\n! exclamation mark\n</code></pre>"},{"location":"ayuda/material/#codigo","title":"C\u00f3digo","text":"<p>Para marcar texto como c\u00f3digo es necesario indentar cada l\u00ednea del bloque con cuatro espacios o una tabulaci\u00f3n. Si el c\u00f3digo va embebido en un p\u00e1rrafo, es neceario rodearlo por comillas simples invertidas. Consultar la secci\u00f3n de CodeHilite y de InlineHilite para funcionalidades extendidas.</p>"},{"location":"ayuda/material/#extensiones","title":"Extensiones","text":""},{"location":"ayuda/material/#admonition","title":"Admonition","text":"<p>Extensi\u00f3n incluida en la librer\u00eda est\u00e1ndar de Markdown que permite incluir contenido adicional en cajas de color con un t\u00edtulo y un icono. Por ejemplo para res\u00famenes, notas, consejos o avisos.</p> <pre><code>!!! note\n    Esto es un ejemplo de nota (note, seealso).\n</code></pre> <p>Note</p> <p>Esto es un ejemplo de nota (note, seealso).</p> <pre><code>!!! note \"Esta es una nota con t\u00edtulo\"\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n    Nulla et euismod nulla. Curabitur feugiat, tortor non\n    consequat finibus, justo purus auctor massa, nec semper\n    lorem quam in massa.\n</code></pre> <p>Esta es una nota con t\u00edtulo</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <pre><code>!!! note \"\"\n    Esta nota va sin t\u00edtulo.\n</code></pre> <p>Esta nota va sin t\u00edtulo.</p> <p>En vez de note es posible utilizar las siguientes etiquetas: summary, info, tip, success, question, warning, failure, danger, bug y quote.</p> <p>Summary</p> <p>Esto es un ejemplo de sumario (summary, tldr).</p> <p>Info</p> <p>Esto es un ejemplo de bloque informativo (info, todo).</p> <p>Tip</p> <p>Esto es un ejemplo de consejo o truco (tip, hint, important).</p> <p>Success</p> <p>Esto es un ejemplo de bloque de \u00e9xito (success, check, done).</p> <p>Question</p> <p>Esto es un ejemplo de pregunta (question, help, faq).</p> <p>Warning</p> <p>Esto es un ejemplo de precauci\u00f3n (warning, caution, attention).</p> <p>Failure</p> <p>Esto es un ejemplo de fallo (failure, fail, missing).</p> <p>Danger</p> <p>Esto es un ejemplo de peligro (danger, error).</p> <p>Bug</p> <p>Esto es un ejemplo de error (bug).</p> <p>Quote</p> <p>Esto es un ejemplo de cita (quote, cite).</p>"},{"location":"ayuda/material/#details","title":"Details","text":"<p>Para crear bloques colapsables que puedan ocultar su contenido.</p> <p>Ejemplo: <pre><code>??? \"Bloque cerrado. Abreme !!!\"\n    Ahora lo has abierto.\n</code></pre> Resultado:</p> Bloque cerrado. Abreme !!! <p>Ahora lo has abierto.</p> <p>Ejemplo: <pre><code>???+ \"Bloque abierto inicialmente\"\n\n    ??? \"Bloque dentro de otro bloque\"\n        Algo de contenido.\n</code></pre> Resultado:</p> Bloque abierto inicialmente Bloque dentro de otro bloque <p>Algo de contenido.</p> <p>Ejemplo: <pre><code>??? danger \"Bloque con tema de peligro\"\n    Algo de contenido.\n</code></pre> Resultado:</p> Bloque con tema de peligro <p>Algo de contenido.</p> Bloque con tema de precauci\u00f3n <p>Algo de contenido.</p> Bloque con tema de \u00e9xito <p>Algo de contenido.</p>"},{"location":"ayuda/material/#codehilite","title":"CodeHilite","text":"<p>Extensi\u00f3n incluida en la librer\u00eda est\u00e1ndar de Markdown que permite resaltar la sintaxis de los bloques de c\u00f3digo. Como lenguajes soportados est\u00e1n entre otros: markdown, python, c, cpp, csharp, html, javascript, JSON, XML.</p> <p>Ejemplo utilizando comillas simples.</p> <pre><code>``` python\nimport tensorflow as tf\n```\n</code></pre> <p>Resultado:</p> <pre><code>import tensorflow as tf\n</code></pre> <p>Ejemplo utilizando bloque tabulado con cuatro espacios:</p> <pre><code>    :::python\n    \"\"\" Bubble sort \"\"\"\n    def bubble_sort(items):\n        for i in range(len(items)):\n            for j in range(len(items) - 1 - i):\n                if items[j] &gt; items[j + 1]:\n                    items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre> <p>Resultado:</p> <pre><code>:::python\n\"\"\" Bubble sort \"\"\"\ndef bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre> <p>Ejemplo utilizando bloque tabulado y n\u00fameros de l\u00ednea:</p> <pre><code>    #!python\n    \"\"\" Bubble sort \"\"\"\n    def bubble_sort(items):\n        for i in range(len(items)):\n            for j in range(len(items) - 1 - i):\n                if items[j] &gt; items[j + 1]:\n                    items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre> <p>Resultado:</p> <pre><code>#!python\n\"\"\" Bubble sort \"\"\"\ndef bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre> <p>Es posible resaltar l\u00edneas concretas de c\u00f3digo con hl_lines.</p> <pre><code>    #!python hl_lines=\"3 4\"\n</code></pre> <p>Resultado:</p> <pre><code>#!python hl_lines=\"3 4\"\n\"\"\" Bubble sort \"\"\"\ndef bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"ayuda/material/#inlinehilite","title":"InlineHilite","text":"<p>Permite embeber c\u00f3digo en el texto mediante <code>#!languaje code</code> o bien <code>:::languaje code</code> entre comillas simples inversas.</p> <p>Ejemplo: <pre><code>Aqui se presenta este c\u00f3digo `#!c #include &lt;stdio.h&gt;` embebido en el texto.\n</code></pre> Resultado:</p> <p>Aqui se presenta este c\u00f3digo <code>#include &lt;stdio.h&gt;</code> embebido en el texto.</p> <p>Ejemplo: <pre><code>Aqui se presenta este otro c\u00f3digo `:::c #include &lt;stdlib.h&gt;` embebido en el texto.\n</code></pre> Resultado:</p> <p>Aqui se presenta este otro c\u00f3digo <code>#include &lt;stdlib.h&gt;</code> embebido en el texto.</p> <p>Ejemplo: <pre><code>C\u00f3digo javascript: `#!js function pad(v){return ('0'+v).split('').reverse().splice(0,2).reverse().join('')}`.\n</code></pre> Resultado:</p> <p>C\u00f3digo javascript: <code>function pad(v){return ('0'+v).split('').reverse().splice(0,2).reverse().join('')}</code>.</p>"},{"location":"ayuda/material/#mark","title":"Mark","text":"<p>Permite marcar texto en amarillo fosforito.</p> <p>La anterior frase se ha generado as\u00ed: <pre><code>Permite marcar texto en ==amarillo fosforito==.\n</code></pre></p>"},{"location":"ayuda/material/#footnotes","title":"Footnotes","text":"<p>Otra extensi\u00f3n de la libreria est\u00e1ndar para incluir notas al pie de p\u00e1gina. Se inserta una referencia en el texto, la cual puede ser definida en cualquier parte del documento. La definici\u00f3n aparecer\u00e1 en el pie de p\u00e1gina. La referencia consiste en un sombrerete seguido de un identificador num\u00e9rico [1, 2, 3, ...] o bien de nombres [Cuartas et al. 2012].</p> <p>Ejemplo:</p> <pre><code>Lorem ipsum[^1] dolor sit amet, consectetur adipiscing elit.[^2]\n</code></pre> <p>Resultado:</p> <p>Lorem ipsum<sup>1</sup> dolor sit amet, consectetur adipiscing elit.<sup>2</sup></p> <p>La definici\u00f3n de los contenidos de la nota al pie puede realizarse en una \u00fanica l\u00ednea si el texto es corto:</p> <pre><code>[^1]: Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n</code></pre> <p>o bien en un bloque de texto indentado cuatro espacios, que comienze en la siguiente l\u00ednea de la etiqueta, si el texto es largo.</p> <pre><code>[^2]:\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\n    nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\n    massa, nec semper lorem quam in massa.\n</code></pre>"},{"location":"ayuda/material/#arithmatex-mathjax","title":"Arithmatex MathJax","text":"<p>Basado en MathJax. Permite introducir equaciones escritas en TeX dentro de bloques o en l\u00ednea con el texto. Ver este hilo para una r\u00e1pida referencia sobre la sintaxis TeX.</p> <p>Ejemplo: <pre><code>$$\\frac{n!}{k!(n-k)!} = \\binom{n}{k}$$\n\n$$\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}$$\n</code></pre> Resultado:</p> \\[\\frac{n!}{k!(n-k)!} = \\binom{n}{k}\\] \\[\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}\\] <p>Ejemplo: <pre><code>Lorem ipsum dolor sit amet: $p(x|y) = \\frac{p(y|x)p(x)}{p(y)}$\n</code></pre></p> <p>Resultado:</p> <p>Lorem ipsum dolor sit amet: \\(p(x|y) = \\frac{p(y|x)p(x)}{p(y)}\\)</p>"},{"location":"ayuda/material/#letras-griegas","title":"Letras griegas","text":"<p><code>$\\alpha, \\beta, ..., \\omega$</code></p> <p>\\(\\alpha, \\beta, ..., \\omega\\)</p> <p><code>$\\Gamma, \\Delta, ..., \\Omega$</code></p> <p>\\(\\Gamma, \\Delta, ..., \\Omega\\)</p>"},{"location":"ayuda/material/#superindices-y-subindices","title":"Superindices y subindices","text":"<p><code>$x_i^2  \\log_2 x$</code></p> <p>\\(x_i^2  \\log_2 x\\)</p>"},{"location":"ayuda/material/#grupos","title":"Grupos","text":"<p>Super\u00edndices, sub\u00edndices y otras operaciones aplican solamente al siguiente \"grupo\". Un \"grupo\" es un \u00fanico s\u00edmbolo o un cualquier f\u00f3rmula ubicada entre llaves {...}</p> <p><code>$10^10$</code></p> <p>\\(10^10\\)</p> <p><code>$10^{10}$</code></p> <p>\\(10^{10}\\)</p> <p><code>${x^y}^z$</code></p> <p>\\({x^y}^z\\)</p> <ol> <li> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.\u00a0\u21a9</p> </li> <li> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.\u00a0\u21a9</p> </li> </ol>"}]}